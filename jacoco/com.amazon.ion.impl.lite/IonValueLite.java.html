<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonValueLite.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl.lite</a> &gt; <span class="el_source">IonValueLite.java</span></div><h1>IonValueLite.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl.lite;

import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static com.amazon.ion.impl._Private_Utils.EMPTY_STRING_ARRAY;
import static com.amazon.ion.impl._Private_Utils.newSymbolToken;
import static com.amazon.ion.util.Equivalence.ionEquals;

import com.amazon.ion.IonDatagram;
import com.amazon.ion.IonException;
import com.amazon.ion.IonType;
import com.amazon.ion.IonValue;
import com.amazon.ion.IonWriter;
import com.amazon.ion.NullValueException;
import com.amazon.ion.ReadOnlyValueException;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.UnknownSymbolException;
import com.amazon.ion.ValueVisitor;
import com.amazon.ion.impl._Private_IonValue;
import com.amazon.ion.impl._Private_IonWriter;
import com.amazon.ion.impl._Private_Utils;
import com.amazon.ion.system.IonTextWriterBuilder;
import com.amazon.ion.util.Printer;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *  Base class of the light weight implementation of
 *  Ion values.
 */
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">abstract class IonValueLite</span>
    implements _Private_IonValue
{
<span class="fc" id="L49">    private static final int TYPE_ANNOTATION_HASH_SIGNATURE =</span>
<span class="fc" id="L50">        &quot;TYPE ANNOTATION&quot;.hashCode();</span>

    /**
     * this hold all the various boolean flags we have
     * in a single int.  Use set_flag(), clear_flag(), is_true()
     * and the associated int flag to check the various flags.
     * This is to avoid the overhead java seems to impose
     * for a boolean value - it should be a bit, but it seems
     * to be an int (4 bytes for 1 bit seems excessive).
     */
    protected static final int IS_LOCKED          = 0x01;
    protected static final int IS_SYSTEM_VALUE    = 0x02;
    protected static final int IS_NULL_VALUE      = 0x04;
    protected static final int IS_BOOL_TRUE       = 0x08;
    protected static final int IS_IVM             = 0x10;
    protected static final int IS_AUTO_CREATED    = 0x20;
    protected static final int IS_SYMBOL_PRESENT  = 0x40;
    /**
     * Symbol ID present refers to there being the &lt;i&gt;possibility&lt;/i&gt; that the IonValueLite, or it's contained sub graph
     * &lt;i&gt;(e.g. if it is a {@link IonContainerLite} based sub type)&lt;/i&gt; contains one or more defined
     * Symbol ID's (SID)'s. This flag is used to track lifecycle, such that operations that require SID's are purged
     * from the IonValueLite and it's contained sub-DOM can conduct a fast evaluation rather than having to do a full
     * contained graph traversal on each and every invocation.
     */
    protected static final int IS_SYMBOL_ID_PRESENT = 0x80;

    private   static final int ELEMENT_MASK       = 0xff;
    protected static final int ELEMENT_SHIFT      = 8; // low 8 bits is flag, upper 24 (or 48 is element id)

    /**
     * Used by subclasses to retrieve metadata set by
     * {@link #_setMetadata(int, int, int)}.
     * @param mask the location of the metadata to retrieve.
     * @param shift the number of bits to right-shift the metadata so that
     *              it starts at bit index 0.
     * @return the metadata from _flags at the given mask.
     */
    protected final int _getMetadata(int mask, int shift) {
<span class="fc" id="L88">        return (_flags &amp; mask) &gt;&gt;&gt; shift;</span>
    }

    /**
     * May be used by subclasses to reuse _flag bits for purposes specific
     * to that subclass. It is important that only flag bits not currently
     * used by that subclass are chosen; otherwise important data may be
     * overwritten. NOTE: only the lower 8 bits may be used, because the
     * upper 24 are reserved for the element ID.
     * @param metadata the metadata to set.
     * @param mask the location at which to set the metadata. Must be within
     *             the lower 8 bits.
     * @param shift the number of bits to left-shift the metadata so that
     *              it starts at the index of the mask's LSB.
     */
    protected final void _setMetadata(int metadata, int mask, int shift) {
<span class="pc bpc" id="L104" title="2 of 4 branches missed.">        assert(mask &lt;= ELEMENT_MASK); // don't overwrite the element ID</span>
<span class="fc" id="L105">        _flags &amp;= ~mask;</span>
<span class="fc" id="L106">        _flags |= ((metadata &lt;&lt; shift) &amp; mask);</span>
<span class="fc" id="L107">    }</span>

    protected final void _elementid(int elementid) {
<span class="fc" id="L110">        _flags &amp;= ELEMENT_MASK;</span>
<span class="fc" id="L111">        _flags |= (elementid &lt;&lt; ELEMENT_SHIFT);</span>
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">        assert(_elementid() == elementid);</span>
<span class="fc" id="L113">    }</span>
    protected final int _elementid() {
<span class="fc" id="L115">        int elementid =  _flags  &gt;&gt;&gt; ELEMENT_SHIFT;</span>
<span class="fc" id="L116">        return elementid;</span>
    }

    private final boolean is_true(int flag_bit) {
<span class="fc bfc" id="L120" title="All 2 branches covered.">        return ((_flags &amp; flag_bit) != 0);</span>
    }
    private final void set_flag(int flag_bit) {
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">        assert(flag_bit != 0);</span>
<span class="fc" id="L124">        _flags |= flag_bit;</span>
<span class="fc" id="L125">    }</span>
    private final void clear_flag(int flag_bit) {
<span class="pc bpc" id="L127" title="2 of 4 branches missed.">        assert(flag_bit != 0);</span>
<span class="fc" id="L128">        _flags &amp;= ~flag_bit;</span>
<span class="fc" id="L129">    }</span>

<span class="fc" id="L131">    protected final boolean _isLocked() { return is_true(IS_LOCKED); }</span>
    protected final boolean _isLocked(boolean flag) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (flag) {</span>
<span class="fc" id="L134">            set_flag(IS_LOCKED);</span>
        }
        else {
<span class="nc" id="L137">            clear_flag(IS_LOCKED);</span>
        }
<span class="fc" id="L139">        return flag;</span>
    }
<span class="nc" id="L141">    protected final boolean _isSystemValue() { return is_true(IS_SYSTEM_VALUE); }</span>
    protected final boolean _isSystemValue(boolean flag) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (flag) {</span>
<span class="nc" id="L144">            set_flag(IS_SYSTEM_VALUE);</span>
        }
        else {
<span class="nc" id="L147">            clear_flag(IS_SYSTEM_VALUE);</span>
        }
<span class="nc" id="L149">        return flag;</span>
    }
<span class="fc" id="L151">    protected final boolean _isNullValue() { return is_true(IS_NULL_VALUE); }</span>
    protected final boolean _isNullValue(boolean flag) {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (flag) {</span>
<span class="fc" id="L154">            set_flag(IS_NULL_VALUE);</span>
        }
        else {
<span class="fc" id="L157">            clear_flag(IS_NULL_VALUE);</span>
        }
<span class="fc" id="L159">        return flag;</span>
    }
<span class="fc" id="L161">    protected final boolean _isBoolTrue() { return is_true(IS_BOOL_TRUE); }</span>
    protected final boolean _isBoolTrue(boolean flag) {
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (flag) {</span>
<span class="fc" id="L164">            set_flag(IS_BOOL_TRUE);</span>
        }
        else {
<span class="fc" id="L167">            clear_flag(IS_BOOL_TRUE);</span>
        }
<span class="fc" id="L169">        return flag;</span>
    }

<span class="nc" id="L172">    protected final boolean _isIVM() { return is_true(IS_IVM); }</span>
    protected final boolean _isIVM(boolean flag) {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (flag) {</span>
<span class="nc" id="L175">            set_flag(IS_IVM);</span>
        }
        else {
<span class="nc" id="L178">            clear_flag(IS_IVM);</span>
        }
<span class="nc" id="L180">        return flag;</span>
    }

<span class="fc" id="L183">    protected final boolean _isAutoCreated() { return is_true(IS_AUTO_CREATED); }</span>
    protected final boolean _isAutoCreated(boolean flag) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (flag) {</span>
<span class="nc" id="L186">            set_flag(IS_AUTO_CREATED);</span>
        }
        else {
<span class="nc" id="L189">            clear_flag(IS_AUTO_CREATED);</span>
        }
<span class="nc" id="L191">        return flag;</span>
    }

<span class="fc" id="L194">    protected final boolean _isSymbolPresent() { return is_true(IS_SYMBOL_PRESENT); }</span>
    protected final boolean _isSymbolPresent(boolean flag) {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (flag) {</span>
<span class="fc" id="L197">            set_flag(IS_SYMBOL_PRESENT);</span>
        }
        else {
<span class="nc" id="L200">            clear_flag(IS_SYMBOL_PRESENT);</span>
        }
<span class="fc" id="L202">        return flag;</span>
    }

<span class="fc" id="L205">    protected final boolean _isSymbolIdPresent() { return is_true(IS_SYMBOL_ID_PRESENT); }</span>
    protected final boolean _isSymbolIdPresent(boolean flag) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (flag) {</span>
<span class="fc" id="L208">            set_flag(IS_SYMBOL_ID_PRESENT);</span>
        }
        else {
<span class="fc" id="L211">            clear_flag(IS_SYMBOL_ID_PRESENT);</span>
        }
<span class="fc" id="L213">        return flag;</span>
    }

    /**
     * Lazy memoized symtab provider. Should be used when a call path
     * conditionally needs access to a value's symbol table. This provider
     * can be &quot;passed down&quot; through the path, cutting down on
     * potentially expensive IonValue#getSymbolTable calls.
     */
    static class LazySymbolTableProvider
        implements SymbolTableProvider
    {
<span class="fc" id="L225">        SymbolTable symtab = null;</span>
        final IonValueLite value;

        LazySymbolTableProvider(IonValueLite value)
<span class="fc" id="L229">        {</span>
<span class="fc" id="L230">            this.value = value;</span>
<span class="fc" id="L231">        }</span>

        public SymbolTable getSymbolTable()
        {
<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (symtab == null)</span>
            {
<span class="fc" id="L237">                symtab = value.getSymbolTable();</span>
            }
<span class="fc" id="L239">            return symtab;</span>
        }

    }

    /*
     * KEEP ALL MEMBER FIELDS HERE!
     *
     * This impl is intended to have a very light memory footprint. So tracking
     * member fields is especially important.
     *
     * SO PLEASE KEEP THE MEMBER DECLARATIONS HERE AND TOGETHER!
     *
     * Thank you.
     *
     * If this instance is not a struct field, then
     *   _fieldId = UNKNOWN_SYMBOL_ID  and  _fieldName = null
     * Otherwise, at least one must be defined.
     */
    private   int              _flags;
<span class="fc" id="L259">    private   int              _fieldId = UNKNOWN_SYMBOL_ID;</span>

    /** Not null. */
    protected IonContext       _context;
    private   String           _fieldName;

    /**
     * The annotation sequence. This array is overallocated and may have
     * nulls at the end denoting unused slots.
     */
    private   SymbolToken[] _annotations;

    // current size 32 bit: 3*4 + 4 +  8 = 24 (32 bytes allocated)
    //              64 bit: 3*8 + 4 + 16 = 52 (56 bytes allocated)

    /**
     * The constructor, which is called from the concrete subclasses'
     * constructors.
     *
     * @param context the context that this value is associated with
     * @param isNull if true, sets the null bit in the flags member field
     */
    IonValueLite(ContainerlessContext context, boolean isNull)
<span class="fc" id="L282">    {</span>
<span class="pc bpc" id="L283" title="2 of 4 branches missed.">        assert context != null;</span>
<span class="fc" id="L284">        _context = context;</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (isNull) {</span>
<span class="fc" id="L286">            set_flag(IS_NULL_VALUE);</span>
        }
<span class="fc" id="L288">    }</span>

    /**
     * Copy Constructor *purely* for cloning - NOTE; this means that the clone is not &lt;i&gt;perfect&lt;/i&gt;
     * as if the original entity was &lt;b&gt;read-only&lt;/b&gt; the cloned value will now be &lt;b&gt;mutable&lt;/b&gt;.
     *
     * @param existing the non-null existing IonValueLite entity to clone
     * @param context the non-null parent context to use for the cloned entity.
     */
<span class="fc" id="L297">    IonValueLite(IonValueLite existing, IonContext context) {</span>
        // Symbols are *immutable* therefore a shallow copy is sufficient
<span class="fc" id="L299">        boolean hasSIDsRetained = false;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (null == existing._annotations) {</span>
<span class="fc" id="L301">            this._annotations = null;</span>
        } else {
<span class="fc" id="L303">            int size = existing._annotations.length;</span>
<span class="fc" id="L304">            this._annotations = new SymbolToken[size];</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L306">                SymbolToken existingToken = existing._annotations[i];</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">                if (existingToken != null) {</span>
<span class="fc" id="L308">                    String text = existingToken.getText();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                    if (text != null) {</span>
<span class="fc" id="L310">                        this._annotations[i] =</span>
<span class="fc" id="L311">                            _Private_Utils.newSymbolToken(text, UNKNOWN_SYMBOL_ID);</span>
                    } else {
                        // TODO - amzn/ion-java/issues/223 needs consistent handling, should attempt to resolve and if it cant; fail
<span class="fc" id="L314">                        this._annotations[i] = existing._annotations[i];</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                        hasSIDsRetained |= this._annotations[i].getSid() &gt; UNKNOWN_SYMBOL_ID;</span>
                    }
                }
            }
        }
        // We don't copy the field name, that happens in IonStruct's clone
<span class="fc" id="L321">        this._flags       = existing._flags;</span>
<span class="fc" id="L322">        this._context     = context;</span>

        // as IonValue.clone() mandates that the returned value is mutable, regardless of the
        // existing 'read only' flag - we force the deep-copy back to being mutable
<span class="fc" id="L326">        clear_flag(IS_LOCKED);</span>
        // whilst the clone *should* guarantee symbol context is purged, the annotation behavior existing above
        // under the TO DO for amzn/ion-java/issues/223 does mean that SID context can be propogated through a clone, therefore
        // the encoding flag has to reflect this reality
<span class="fc" id="L330">        _isSymbolIdPresent(hasSIDsRetained);</span>
<span class="fc" id="L331">    }</span>

    public abstract void accept(ValueVisitor visitor) throws Exception;

    public /* synchronized */ void addTypeAnnotation(String annotation)
    {
<span class="fc" id="L337">        checkForLock();</span>

<span class="pc bpc" id="L339" title="2 of 4 branches missed.">        if (annotation == null || annotation.length() &lt; 1) {</span>
<span class="nc" id="L340">            throw new IllegalArgumentException(&quot;a user type annotation must be a non-empty string&quot;);</span>
        }

        // we don't add duplicate annotations
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (hasTypeAnnotation(annotation)) return;</span>

<span class="fc" id="L346">        SymbolToken sym = newSymbolToken(annotation, UNKNOWN_SYMBOL_ID);</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">        int old_len = (_annotations == null) ? 0 : _annotations.length;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (old_len &gt; 0) {</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            for (int ii=0; ii&lt;old_len; ii++) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (_annotations[ii] == null) {</span>
<span class="fc" id="L352">                    _annotations[ii] = sym;</span>
<span class="fc" id="L353">                    return;</span>
                }
            }
        }

<span class="fc bfc" id="L358" title="All 2 branches covered.">        int new_len = (old_len == 0) ? 1 : old_len * 2;</span>
<span class="fc" id="L359">        SymbolToken temp[] = new SymbolToken[new_len];</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (old_len &gt; 0) {</span>
<span class="fc" id="L361">            System.arraycopy(_annotations, 0, temp, 0, old_len);</span>
        }
<span class="fc" id="L363">        _annotations = temp;</span>
<span class="fc" id="L364">        _annotations[old_len] = sym;</span>
<span class="fc" id="L365">    }</span>

    public final /* synchronized */ void clearTypeAnnotations()
    {
<span class="fc" id="L369">        checkForLock();</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">        int old_len = (_annotations == null) ? 0 : _annotations.length;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (old_len &gt; 0) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            for (int ii=0; ii&lt;old_len; ii++) {</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                if (_annotations[ii] == null) {</span>
<span class="nc" id="L375">                    break;</span>
                }
<span class="fc" id="L377">                _annotations[ii] = null;</span>
            }
        }

        // although annotations have been removed from the node, which *may* mean the sub-graph from this Node is
        // now without encodings... the check is expensive for container types (need to check all immediate children)
        // and so we will opt to clear down encoding present in a lazy fashion (e.g. when something actually needs it)
<span class="fc" id="L384">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The user can only call this method on the concrete (not abstract)
     * subclasses of IonValueLite (e.g. IonIntLite). The explicit clone logic
     * is contained in {@link #clone(IonContext)} which should in turn be implemented by
     * using a copy-constructor.
     */
    @Override
    public abstract IonValue clone();

    abstract IonValueLite clone(IonContext parentContext);


    /**
     * Since {@link #equals(Object)} is overridden, each concrete class must provide
     * an implementation of {@link Object#hashCode()}.
     * @return hash code for instance consistent with equals().
     */
    /*
     * internally ALL implementations will be delegated too with the SymbolTable
     * which is to prevent the SymbolTable being continually re-located in complex structures.
     *
     * This is near universally true - however does not apply for IonDatagramLite - hence it
     * explicitly overrides hashCode()
     */
    @Override
    public int hashCode() {
        // Supply a lazy symbol table provider, which will call getSymbolTable()
        // only once it's actually necessary.
        // This works for all child types with the exception of
        // IonDatagramLite which has a different, explicit behavior for hashCode()
        // (hence this method cannot be final).
<span class="fc" id="L419">        return hashCode(new LazySymbolTableProvider(this));</span>
    }

    /*
     * Internal HashCode implementation which utilizes a SymbolTableProvider
     * to resolve the SymbolTable to use in encoding the sub-graph.
     */
    abstract int hashCode(SymbolTableProvider symbolTableProvider);

    public IonContainerLite getContainer()
    {
<span class="fc" id="L430">        return _context.getContextContainer();</span>
    }

    public IonValueLite topLevelValue()
    {
<span class="pc bpc" id="L435" title="2 of 4 branches missed.">        assert ! (this instanceof IonDatagram);</span>

<span class="fc" id="L437">        IonValueLite value = this;</span>
        for (;;) {
<span class="fc" id="L439">            IonContainerLite c = value._context.getContextContainer();</span>
<span class="fc bfc" id="L440" title="All 4 branches covered.">            if (c == null || c instanceof IonDatagram) {</span>
<span class="fc" id="L441">                break;</span>
            }
<span class="fc" id="L443">            value = c;</span>
<span class="fc" id="L444">        }</span>
<span class="fc" id="L445">        return value;</span>
    }


    public final int getElementId()
    {
<span class="fc" id="L451">        return this._elementid();</span>
    }


    public final int getFieldId()
    {
<span class="fc bfc" id="L457" title="All 4 branches covered.">        if (_fieldId != UNKNOWN_SYMBOL_ID || _fieldName == null)</span>
        {
<span class="fc" id="L459">            return _fieldId;</span>
        }

<span class="fc" id="L462">        SymbolToken tok = getSymbolTable().find(_fieldName);</span>

<span class="fc bfc" id="L464" title="All 2 branches covered.">        return (tok != null ? tok.getSid() : UNKNOWN_SYMBOL_ID);</span>
    }


    public SymbolToken getFieldNameSymbol()
    {
        // TODO amzn/ion-java/issues/27 We should memoize the results of symtab lookups.
        // BUT: that could cause thread-safety problems for read-only values.
        // I think makeReadOnly should populate the tokens fully
        // so that we only need to lookup from mutable instances.
        // However, the current invariants on these fields are nonexistant so
        // I do not trust that its safe to alter them here.

<span class="fc" id="L477">        return getFieldNameSymbol(new LazySymbolTableProvider(this));</span>
    }

    public final SymbolToken getFieldNameSymbol(SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L482">        int sid = _fieldId;</span>
<span class="fc" id="L483">        String text = _fieldName;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (text != null)</span>
        {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            if (sid == UNKNOWN_SYMBOL_ID)</span>
            {
<span class="fc" id="L488">                SymbolToken tok = symbolTableProvider.getSymbolTable().find(text);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                if (tok != null)</span>
                {
<span class="fc" id="L491">                    return tok;</span>
                }
<span class="fc" id="L493">            }</span>
        }
<span class="fc bfc" id="L495" title="All 2 branches covered.">        else if (sid &gt; 0) {</span>
<span class="fc" id="L496">            text = symbolTableProvider.getSymbolTable().findKnownSymbol(sid);</span>
        }
<span class="fc bfc" id="L498" title="All 2 branches covered.">        else if(sid != 0){</span>
            // not a struct field
<span class="fc" id="L500">            return null;</span>
        }
<span class="fc" id="L502">        return _Private_Utils.newSymbolToken(text, sid);</span>
    }

    public final SymbolToken getKnownFieldNameSymbol()
    {
<span class="fc" id="L507">        SymbolToken token = this.getFieldNameSymbol();</span>
<span class="pc bpc" id="L508" title="2 of 4 branches missed.">        if (token.getText() == null &amp;&amp; token.getSid() != 0) {</span>
<span class="nc" id="L509">            throw new UnknownSymbolException(_fieldId);</span>
        }
<span class="fc" id="L511">        return token;</span>
    }

    final boolean clearSymbolIDValues()
    {
        // short circuit exit - no SID's present to remove - so can exit immediately
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (!_isSymbolIdPresent())</span>
        {
<span class="fc" id="L519">            return true;</span>
        }

<span class="fc" id="L522">        boolean allSIDsRemoved = attemptClearSymbolIDValues();</span>
        // if all the SID's have been successfully removed - the SID Present flag can be set to false
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (allSIDsRemoved)</span>
        {
            // clear the symbolID status flag
<span class="fc" id="L527">            _isSymbolIdPresent(false);</span>
        }
<span class="fc" id="L529">        return allSIDsRemoved;</span>
    }

    /**
     * Sets this value's symbol table to null, and erases any SIDs here and
     * recursively.
     *
     * @return true if all SID's have been successfully removed, otherwise false
     */
    boolean attemptClearSymbolIDValues()
    {
<span class="fc" id="L540">        boolean sidsRemain = false;</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (_fieldName != null)</span>
        {
<span class="fc" id="L543">            _fieldId = UNKNOWN_SYMBOL_ID;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">        } else if (_fieldId &gt; UNKNOWN_SYMBOL_ID)</span>
        {
            // retaining the field SID, as it couldn't be cleared due to loss of context
            // TODO - for SID handling consistency; this should attempt resolution first
<span class="fc" id="L548">            sidsRemain = true;</span>
        }

<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (_annotations != null)</span>
        {
<span class="fc bfc" id="L553" title="All 2 branches covered.">            for (int i = 0; i &lt; _annotations.length; i++)</span>
            {
<span class="fc" id="L555">                SymbolToken annotation = _annotations[i];</span>

                // _annotations may have nulls at the end.
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">                if (annotation == null) break;</span>

<span class="fc" id="L560">                String text = annotation.getText();</span>
                // TODO - for SID handling consistency; this should attempt resolution first, not just drop entry
<span class="fc bfc" id="L562" title="All 4 branches covered.">                if (text != null &amp;&amp; annotation.getSid() != UNKNOWN_SYMBOL_ID)</span>
                {
<span class="fc" id="L564">                    _annotations[i] =</span>
<span class="fc" id="L565">                        newSymbolToken(text, UNKNOWN_SYMBOL_ID);</span>
                }
            }
        }

<span class="fc bfc" id="L570" title="All 2 branches covered.">        return !sidsRemain;</span>
    }

    protected void cascadeSIDPresentToContextRoot() {
        // start with self
<span class="fc" id="L575">        IonValueLite node = this;</span>
        // iterate from leaf to context root setting encoding present until either context root is hit OR a node is
        // encountered that already has encodings present (and so no further propogation is required).
<span class="fc bfc" id="L578" title="All 4 branches covered.">        while (null != node &amp;&amp; !node._isSymbolIdPresent()) {</span>
<span class="fc" id="L579">            node._isSymbolIdPresent(true);</span>
<span class="fc" id="L580">            node = node.getContainer();</span>
        }
<span class="fc" id="L582">    }</span>

    final void setFieldName(String name)
    {
<span class="pc bpc" id="L586" title="2 of 4 branches missed.">        assert getContainer() instanceof IonStructLite;</span>
        // We can never change a field name once it's set.
<span class="pc bpc" id="L588" title="3 of 6 branches missed.">        assert _fieldId == UNKNOWN_SYMBOL_ID &amp;&amp; _fieldName == null;</span>
<span class="fc" id="L589">        _fieldName = name;</span>
<span class="fc" id="L590">    }</span>

    /**
     * Sets the field name and ID based on a SymbolToken.
     * Both parts of the SymbolToken are trusted!
     *
     * @param name is not retained by this value, but both fields are copied.
     */
    final void setFieldNameSymbol(SymbolToken name)
    {
<span class="pc bpc" id="L600" title="3 of 6 branches missed.">        assert _fieldId == UNKNOWN_SYMBOL_ID &amp;&amp; _fieldName == null;</span>
<span class="fc" id="L601">        _fieldName = name.getText();</span>
<span class="fc" id="L602">        _fieldId   = name.getSid();</span>

        // if a SID has been added by this operation to a previously SID-less node we have to mark upwards
        // towards the context root that a SID is present
<span class="fc bfc" id="L606" title="All 4 branches covered.">        if (UNKNOWN_SYMBOL_ID != _fieldId &amp;&amp; !_isSymbolIdPresent()) {</span>
<span class="fc" id="L607">            cascadeSIDPresentToContextRoot();</span>
        }
<span class="fc" id="L609">    }</span>

    public final String getFieldName()
    {
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (_fieldName != null) return _fieldName;</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (_fieldId &lt;= 0) return null;</span>

        // TODO amzn/ion-java/issues/27 why no symtab lookup, like getFieldNameSymbol()?
<span class="fc" id="L617">        throw new UnknownSymbolException(_fieldId);</span>
    }

    public final int getFieldNameId()
    {
<span class="nc" id="L622">        return getFieldId();</span>
    }

    /**
     * @return not null, &lt;b&gt;in conflict with the public documentation&lt;/b&gt;.
     */
    public SymbolTable getSymbolTable()
    {
<span class="pc bpc" id="L630" title="2 of 4 branches missed.">        assert ! (this instanceof IonDatagram);</span>

<span class="fc" id="L632">        SymbolTable symbols = topLevelValue()._context.getContextSymbolTable();</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        if (symbols != null) {</span>
<span class="fc" id="L634">            return symbols;</span>
        }
<span class="fc" id="L636">        return getSystem().getSystemSymbolTable();</span>
    }

    public SymbolTable getAssignedSymbolTable()
    {
<span class="pc bpc" id="L641" title="2 of 4 branches missed.">        assert ! (this instanceof IonDatagram);</span>

<span class="fc" id="L643">        SymbolTable symbols = _context.getContextSymbolTable();</span>
<span class="fc" id="L644">        return symbols;</span>
    }

    public IonSystemLite getSystem()
    {
<span class="fc" id="L649">        return _context.getSystem();</span>
    }

    public IonType getType()
    {
<span class="nc" id="L654">        throw new UnsupportedOperationException(&quot;this type &quot;+this.getClass().getSimpleName()+&quot; should not be instantiated, there is not IonType associated with it&quot;);</span>
    }

    public SymbolToken[] getTypeAnnotationSymbols()
    {
<span class="fc" id="L659">        return getTypeAnnotationSymbols(new LazySymbolTableProvider(this));</span>
    }

    public final SymbolToken[] getTypeAnnotationSymbols(SymbolTableProvider symbolTableProvider)
    {
        // first we have to count the number of non-null
        // elements there are in the annotations array
<span class="fc" id="L666">        int count = 0;</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">        if (_annotations != null) {</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            for (int i = 0; i &lt; _annotations.length; i++) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (_annotations[i] != null) {</span>
<span class="fc" id="L670">                    count++;</span>
                }
            }
        }
        // if there aren't any, we're done
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L676">            return SymbolToken.EMPTY_ARRAY;</span>
        }

<span class="fc" id="L679">        SymbolToken[] users_copy = new SymbolToken[count];</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L682">            SymbolToken token = _annotations[i];</span>
<span class="fc" id="L683">            String text = token.getText();</span>
<span class="pc bpc" id="L684" title="1 of 4 branches missed.">            if (text != null &amp;&amp; token.getSid() == UNKNOWN_SYMBOL_ID)</span>
            {
                // TODO amzn/ion-java/issues/27 We should memoize the result of symtab lookups
                // into _annotations.
                // See getFieldNameSymbol() for challenges doing so.

<span class="fc" id="L690">                SymbolToken interned = symbolTableProvider.getSymbolTable().find(text);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">                if (interned != null)</span>
                {
<span class="fc" id="L693">                    token = interned;</span>
                }
            }

<span class="fc" id="L697">            users_copy[i] = token;</span>
        }
<span class="fc" id="L699">        return users_copy;</span>
    }

    public void setTypeAnnotationSymbols(SymbolToken... annotations)
    {
<span class="fc" id="L704">        checkForLock();</span>

<span class="pc bpc" id="L706" title="1 of 4 branches missed.">        if (annotations == null || annotations.length == 0)</span>
        {
            // Normalize all empty lists to the same instance.
<span class="fc" id="L709">            _annotations = SymbolToken.EMPTY_ARRAY;</span>
        }
        else
        {
<span class="fc" id="L713">            _annotations = annotations.clone();</span>

            // new annotations could have SID's - so if this node is not currently marked as SID
            // present then the new annotations have to be interrogated to see if they contain SID's and if they
            // do - the SID Present flag must be cascaded.
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (!_isSymbolIdPresent()) {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                for (SymbolToken token : _annotations) {</span>
                    // upon finding first match of a symbol token containing a SID - cascade upwards and exit
<span class="pc bpc" id="L721" title="1 of 4 branches missed.">                    if (null != token &amp;&amp; UNKNOWN_SYMBOL_ID != token.getSid()) {</span>
<span class="fc" id="L722">                        cascadeSIDPresentToContextRoot();</span>
<span class="fc" id="L723">                        break;</span>
                    }
                }
            }
        }
<span class="fc" id="L728">    }</span>

    public final String[] getTypeAnnotations()
    {
        // first we have to count the number of non-null
        // elements there are in the annotations array
<span class="fc" id="L734">        int count = 0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">        if (_annotations != null) {</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">            for (int ii=0; ii&lt;_annotations.length; ) {</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">                if (_annotations[ii] == null) {</span>
<span class="fc" id="L738">                    break;</span>
                }
<span class="fc" id="L740">                ii++;</span>
<span class="fc" id="L741">                count = ii;</span>
            }
        }
        // if there aren't any, we're done
<span class="fc bfc" id="L745" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L746">            return EMPTY_STRING_ARRAY;</span>
        }

<span class="fc" id="L749">        return _Private_Utils.toStrings(_annotations, count);</span>
    }

    public void setTypeAnnotations(String... annotations)
    {
<span class="fc" id="L754">        checkForLock();</span>

<span class="fc" id="L756">        _annotations = _Private_Utils.newSymbolTokens(getSymbolTable(),</span>
                                                       annotations);
<span class="fc" id="L758">    }</span>

    public final boolean hasTypeAnnotation(String annotation)
    {
<span class="fc bfc" id="L762" title="All 4 branches covered.">        if (annotation != null &amp;&amp; annotation.length() &gt; 0) {</span>
<span class="fc" id="L763">            int pos = findTypeAnnotation(annotation);</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (pos &gt;= 0) {</span>
<span class="fc" id="L765">                return true;</span>
            }
        }
<span class="fc" id="L768">        return false;</span>
    }

    public final int findTypeAnnotation(String annotation)
    {
<span class="pc bpc" id="L773" title="3 of 6 branches missed.">        assert(annotation != null &amp;&amp; annotation.length() &gt; 0);</span>

<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (_annotations != null) {</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">            for (int ii=0; ii&lt;_annotations.length; ii++) {</span>
<span class="fc" id="L777">                SymbolToken a = _annotations[ii];</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">                if (a == null) {</span>
<span class="fc" id="L779">                    break;</span>
                }
<span class="fc bfc" id="L781" title="All 2 branches covered.">                if (annotation.equals(a.getText())) {</span>
<span class="fc" id="L782">                    return ii;</span>
                }
            }
        }
<span class="fc" id="L786">        return -1;</span>
    }

    protected int hashTypeAnnotations(final int original, SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L791">        final SymbolToken[] tokens = getTypeAnnotationSymbols(symbolTableProvider);</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (tokens.length == 0)</span>
        {
<span class="fc" id="L794">            return original;</span>
        }

<span class="fc" id="L797">        final int sidHashSalt   = 127;      // prime to salt sid of annotation</span>
<span class="fc" id="L798">        final int textHashSalt  = 31;       // prime to salt text of annotation</span>
<span class="fc" id="L799">        final int prime = 8191;</span>
<span class="fc" id="L800">        int result = original ^ TYPE_ANNOTATION_HASH_SIGNATURE;</span>

<span class="fc" id="L802">        result = prime * original + tokens.length;</span>

<span class="fc bfc" id="L804" title="All 2 branches covered.">        for (final SymbolToken token : tokens)</span>
        {
<span class="fc" id="L806">            String text = token.getText();</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">            int tokenHashCode = text == null</span>
<span class="fc" id="L809">                ? token.getSid()  * sidHashSalt</span>
<span class="fc" id="L810">                : text.hashCode() * textHashSalt;</span>

            // mixing to account for small text and sid deltas
<span class="fc" id="L813">            tokenHashCode ^= (tokenHashCode &lt;&lt; 19) ^ (tokenHashCode &gt;&gt; 13);</span>

<span class="fc" id="L815">            result = prime * result + tokenHashCode;</span>

            // mixing at each step to make the hash code order-dependent
<span class="fc" id="L818">            result ^= (result &lt;&lt; 25) ^ (result &gt;&gt; 7);</span>
        }

<span class="fc" id="L821">        return result;</span>
    }

    /**
     * Implements equality over values.
     * This is currently defined using the Equivalence class.
     *
     * @see com.amazon.ion.util.Equivalence
     *
     * @param   other   The value to compare with.
     *
     * @return  A boolean, true if the other value is an Ion Value that is the same
     *          content and annotations.
     */
    @Override
    public final boolean equals(final Object other)
    {
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (other == this) {</span>
            // we shouldn't make 3 deep method calls for this common case
<span class="fc" id="L840">            return true;</span>
        }
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">        if (other instanceof IonValue)</span>
        {
<span class="fc" id="L844">            return ionEquals(this, (IonValue) other);</span>
        }
<span class="nc" id="L846">        return false;</span>
    }


    public final boolean isNullValue()
    {
<span class="fc" id="L852">        return _isNullValue();</span>
    }

    public final boolean isReadOnly()
    {
<span class="fc" id="L857">        return _isLocked();</span>
    }

    public void makeReadOnly()
    {
<span class="fc bfc" id="L862" title="All 2 branches covered.">        if (!_isLocked()) {</span>
<span class="fc" id="L863">            makeReadOnlyInternal();</span>
        }
<span class="fc" id="L865">    }</span>

    void makeReadOnlyInternal()
    {
<span class="fc" id="L869">        clearSymbolIDValues();</span>
<span class="fc" id="L870">        _isLocked(true);</span>
<span class="fc" id="L871">    }</span>

    /**
     * Verifies that this value is not read-only.
     *
     * @throws ReadOnlyValueException
     *   if this value {@link #isReadOnly()}.
     */
    final void checkForLock()
        throws ReadOnlyValueException
    {
<span class="fc bfc" id="L882" title="All 2 branches covered.">        if (_isLocked()) {</span>
<span class="fc" id="L883">            throw new ReadOnlyValueException();</span>
        }
<span class="fc" id="L885">    }</span>


    public boolean removeFromContainer()
    {
<span class="fc" id="L890">        checkForLock();</span>

<span class="fc" id="L892">        boolean removed = false;</span>
<span class="fc" id="L893">        IonContainerLite parent = _context.getContextContainer();</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L895">            removed = parent.remove(this);</span>
        }
<span class="fc" id="L897">        return removed;</span>
    }

    public void removeTypeAnnotation(String annotation)
    {
<span class="fc" id="L902">        checkForLock();</span>

<span class="fc bfc" id="L904" title="All 4 branches covered.">        if (annotation != null &amp;&amp; annotation.length() &gt; 0) {</span>
<span class="fc" id="L905">            int pos = findTypeAnnotation(annotation);</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">            if (pos &lt; 0) {</span>
<span class="fc" id="L907">                return;</span>
            }
            int ii;
<span class="fc bfc" id="L910" title="All 2 branches covered.">            for (ii=pos; ii&lt;_annotations.length - 1; ii++) {</span>
<span class="fc" id="L911">                SymbolToken a = _annotations[ii+1];</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">                if (a == null) {</span>
<span class="fc" id="L913">                    break;</span>
                }
<span class="fc" id="L915">                _annotations[ii] = a;</span>
            }
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">            if (ii&lt;_annotations.length) {</span>
<span class="fc" id="L918">                _annotations[ii] = null;</span>
            }
        }
<span class="fc" id="L921">    }</span>

    @Override
    public String toString()
    {
<span class="fc" id="L926">        StringBuilder buf = new StringBuilder(1024);</span>
        try
        {
<span class="fc" id="L929">            Printer p = new Printer();</span>
<span class="fc" id="L930">            p.print(this, buf);</span>
        }
<span class="nc" id="L932">        catch (IOException e)</span>
        {
<span class="nc" id="L934">            throw new IonException(e);</span>
<span class="fc" id="L935">        }</span>
<span class="fc" id="L936">        return buf.toString();</span>
    }

    public String toString(IonTextWriterBuilder writerBuilder)
    {
<span class="fc" id="L941">        StringBuilder buf = new StringBuilder(1024);</span>
        try
        {
<span class="fc" id="L944">            IonWriter writer = writerBuilder.build(buf);</span>
<span class="fc" id="L945">            writeTo(writer);</span>
<span class="fc" id="L946">            writer.finish();</span>
        }
<span class="nc" id="L948">        catch (IOException e)</span>
        {
<span class="nc" id="L950">            throw new IonException(e);</span>
<span class="fc" id="L951">        }</span>
<span class="fc" id="L952">        return buf.toString();</span>
    }

    public String toPrettyString()
    {
<span class="fc" id="L957">        return toString(IonTextWriterBuilder.pretty());</span>
    }

    public void writeTo(IonWriter writer)
    {
        // we use a Lazy 1-time resolution of the SymbolTable in case there is no need to
        // pull the symbol table, including situations where no symbol table would logically
        // be attached
<span class="fc" id="L965">        writeTo(writer, new LazySymbolTableProvider(this));</span>
<span class="fc" id="L966">    }</span>

    final void writeChildren(IonWriter writer, Iterable&lt;IonValue&gt; container,
                             SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L971">        boolean isDatagram = this instanceof IonDatagram;</span>
        // unfortunately JDK5 does not allow for generic co-variant returns; i.e. specifying
        // IonContainerLite#iterator() return type as Iterator&lt;IonValueLite&gt; causes a compile-time
        // error under JDK5 as it doesn't understand this is an acceptable co-variant for
        // Iterator&lt;IonValue&gt; IonContainer#iterator(). This said we know the underlying data
        // structure is IonValueLite[] - so we can conduct the cast within the loop. When ion-java is
        // moved to allow JDK6+ compile time dependency we can remove these crufty casts.
<span class="fc bfc" id="L978" title="All 2 branches covered.">        for (IonValue iv : container) {</span>
<span class="fc" id="L979">            IonValueLite vlite = (IonValueLite) iv;</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">            if(isDatagram)</span>
            {
<span class="nc" id="L982">                vlite.writeTo(writer);</span>
            }
            else
            {
<span class="fc" id="L986">                vlite.writeTo(writer, symbolTableProvider);</span>
            }
<span class="fc" id="L988">        }</span>
<span class="fc" id="L989">    }</span>

    final void writeTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
    {
<span class="fc bfc" id="L993" title="All 2 branches covered.">        if (writer.isInStruct()</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">            &amp;&amp; ! ((_Private_IonWriter) writer).isFieldNameSet())</span>
        {
<span class="fc" id="L996">            SymbolToken tok = getFieldNameSymbol(symbolTableProvider);</span>
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">            if (tok == null)</span>
            {
<span class="nc" id="L999">                throw new IllegalStateException(&quot;Field name not set&quot;);</span>
            }

<span class="fc" id="L1002">            writer.setFieldNameSymbol(tok);</span>
        }

<span class="fc" id="L1005">        SymbolToken[] annotations = getTypeAnnotationSymbols(symbolTableProvider);</span>
<span class="fc" id="L1006">        writer.setTypeAnnotationSymbols(annotations);</span>

        try
        {
<span class="fc" id="L1010">            writeBodyTo(writer, symbolTableProvider);</span>
        }
<span class="nc" id="L1012">        catch (IOException e)</span>
        {
<span class="nc" id="L1014">            throw new IonException(e);</span>
<span class="fc" id="L1015">        }</span>
<span class="fc" id="L1016">    }</span>

    abstract void writeBodyTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
        throws IOException;


    public void setSymbolTable(SymbolTable symbols)
    {
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">        if (getContext() instanceof TopLevelContext){</span>
<span class="nc" id="L1025">            IonDatagramLite datagram = (IonDatagramLite) getContainer();</span>
<span class="nc" id="L1026">            datagram.setSymbolTableAtIndex(_elementid(), symbols);</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        } else if (this.topLevelValue() == this) {</span>
<span class="fc" id="L1028">            setContext(ContainerlessContext.wrap(getContext().getSystem(), symbols));</span>
        } else {
<span class="nc" id="L1030">            throw new UnsupportedOperationException(&quot;can't set the symboltable of a child value&quot;);</span>
        }
<span class="fc" id="L1032">    }</span>

    /**
     * This method is used to re-set the context of an
     * IonValue.  This may occur when the value is added into
     * or removed from a container.  It may occur when the
     * symbol table state of a container changes.
     *
     * @param context must not be null.
     */
    final void setContext(IonContext context)
    {
<span class="pc bpc" id="L1044" title="2 of 4 branches missed.">        assert context != null;</span>
<span class="fc" id="L1045">        checkForLock();</span>

        //Clear all known sIDs.
<span class="fc" id="L1048">        this.clearSymbolIDValues();</span>
<span class="fc" id="L1049">        _context = context;</span>
<span class="fc" id="L1050">    }</span>

    /**
     * used to query the current context.
     *
     * @return this value's context. Not null.
     */
    IonContext getContext()
    {
<span class="fc" id="L1059">        return _context;</span>
    }

    /**
     * Ensures that this value is not an Ion null.  Used as a helper for
     * methods that have that precondition.
     * @throws NullValueException if &lt;code&gt;this.isNullValue()&lt;/code&gt;
     */
    final void validateThisNotNull()
        throws NullValueException
    {
<span class="fc bfc" id="L1070" title="All 2 branches covered.">        if (_isNullValue())</span>
        {
<span class="fc" id="L1072">            throw new NullValueException();</span>
        }
<span class="fc" id="L1074">    }</span>

    /**
     * Removes this value from its container, ensuring that all data stays
     * available.  Dirties this value and it's original container.
     */
    final void detachFromContainer() // throws IOException
    {
<span class="fc" id="L1082">        checkForLock();</span>

<span class="fc" id="L1084">        clearSymbolIDValues();</span>
<span class="fc" id="L1085">        _context = ContainerlessContext.wrap(getSystem());</span>

<span class="fc" id="L1087">        _fieldName = null;</span>
<span class="fc" id="L1088">        _fieldId = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L1089">        _elementid(0);</span>
<span class="fc" id="L1090">    }</span>

    public void dump(PrintWriter out)
    {
<span class="nc" id="L1094">        out.println(this);</span>
<span class="nc" id="L1095">    }</span>

    public String validate()
    {
<span class="nc" id="L1099">        return null;</span>
    }
}

// current size 32 bit: 5*4 + 2 + 1 +  8 = 31 bytes (32 allocated)
//              64 bit: 5*8 + 2 + 1 + 16 = 59 bytes (64 allocated)

/*

private byte             _flags;

private IonValueContextLite _context {
    private IonContainerLite _parent;
    private IonSystem        _system;
    private SymbolTable      _symbolTable;
}

/ * nope: the cost of cloning a value when
* a field name is added seems like over
* kill.
*
* The cost of virtual calls for all value
* access also seems like too high a price
* to pay for the 1 reference saving.
*
* So we'll leave fieldName as a local member
*
//    private IonValueContentLite {
//        union IonValueValueLite {
//            IonContainer
//            IonScalar
//            IonField {
//                String _fieldName;
//            }
//        }
//    }


/ * nope:  by the time you have the reference to the
 *        array list like object (IonValueAnnotations
 *        below) you have half the overhead.  The vast
 *        majority of values have no annotations.  Of
 *        those that have annotations the vast majority
 *        have only 1.  2 and more drop off very quickly.
 *
 *        As such just an array that realloc-ed and the
 *        annotations come and go should be fine.
 *        Certainly the realloc cost is high but the
 *        normal case is alloc for 1 and you're done.
 *
 *        adding support for ignoring null references
 *        means we can mostly calculate the count as
 *        needed, drop out of search loops soon, and
 *        just pay a scan on add annotation.
 *
 * private IonValueAnnotations {
 *   private String[]         _annotations;
 *   private short            _annotation_count;
 * }
 * /
private String[]         _annotations; // just realloc as needed

32 bit: 3*4 + 1

*/

/**
 * ContainingContext is an interface supported
 * by all containers + a ConcreteContext object.
 *
 * For IonDatagramLite and any &quot;uncontained&quot; value
 * the _context member points to a ConcreteContext
 * where:
 *      getContainer return null
 *      getSymbolTable returns the current symbol table
 *      getSystem returns the instance of IonSystemLite
 *        that created this datagram (and it's contained
 *        values)
 *
 * For IonContainerLite each container implements the
 * interface directly.  In addition their _context
 * member has either their parent container or a concrete
 * context.  The IonContainerLite implementations return:
 *
 *      getContainer returns this
 *      getSymbolTable delegates to the _context object
 *      getSystem delegates to the _context object
 *
 *
 *    interface IonContainingContextLite {
 *        IonContainer getParent();
 *        IonSystem    getSystem();
 *        SymbolTable  getSymbolTable();
 *    }
 *
 *   private IonContainerLite _parent;
 *   private IonSystem        _system;
 *   private SymbolTable      _symbolTable;
 *
 */
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>