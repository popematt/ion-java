<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BufferConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion</a> &gt; <span class="el_source">BufferConfiguration.java</span></div><h1>BufferConfiguration.java</h1><pre class="source lang-java linenums">package com.amazon.ion;

import com.amazon.ion.impl.ReaderLookaheadBuffer;

/**
 * Provides logic common to all BufferConfiguration implementations.
 * @param &lt;Configuration&gt; the type of the concrete subclass of this BufferConfiguration that is applicable to the
 *                        ReaderLookaheadBufferBase subclass.
 */
public abstract class BufferConfiguration&lt;Configuration extends BufferConfiguration&lt;Configuration&gt;&gt; {

    /**
     * Functional interface for handling oversized values.
     */
    public interface OversizedValueHandler {
        /**
         * Invoked each time a value (and any symbol tables that immediately precede it) exceed the buffer size limit
         * specified by the LookaheadReaderWrapper instance, but the symbol tables by themselves do not exceed the
         * limit. This is recoverable. If the implementation wishes to recover, it should simply return normally from
         * this method. The oversized value will be flushed from the input pipe; normal processing will resume with the
         * next value. If the implementation wishes to abort processing immediately, it may throw an exception from this
         * method. Such an exception will propagate upward and will be thrown from
         * {@link ReaderLookaheadBuffer#fillInput()}.
         * @throws Exception if handler logic fails.
         */
        void onOversizedValue() throws Exception;
    }

    /**
     * Functional interface for reporting processed data.
     */
    public interface DataHandler {
        /**
         * Invoked whenever the bytes from a value are processed, regardless of whether the bytes are buffered or
         * skipped due to the value being oversized.
         * @param numberOfBytes the number of bytes processed.
         * @throws Exception if handler logic fails.
         */
        void onData(int numberOfBytes) throws Exception;
    }

    /**
     * Provides logic common to all BufferConfiguration Builder implementations.
     * @param &lt;Configuration&gt; the type of BufferConfiguration.
     * @param &lt;BuilderType&gt; the type of Builder that builds BufferConfiguration subclasses of type `Configuration`.
     */
<span class="fc" id="L47">    public static abstract class Builder&lt;</span>
        Configuration extends BufferConfiguration&lt;Configuration&gt;,
        BuilderType extends BufferConfiguration.Builder&lt;Configuration, BuilderType&gt;
    &gt; {

        /**
         * Large enough that most streams will never need to grow the buffer. NOTE: this only needs to be large
         * enough to exceed the length of the longest top-level value plus any system values that precede it.
         */
        static final int DEFAULT_INITIAL_BUFFER_SIZE = 32 * 1024; // bytes

        /**
         * The initial size of the lookahead buffer, in bytes.
         */
<span class="fc" id="L61">        private int initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;</span>

        /**
         * The maximum number of bytes that will be buffered.
         */
<span class="fc" id="L66">        private int maximumBufferSize = Integer.MAX_VALUE;</span>

        /**
         * The handler that will be notified when oversized values are encountered.
         */
<span class="fc" id="L71">        private OversizedValueHandler oversizedValueHandler = null;</span>

        /**
         * The handler that will be notified when data is processed.
         */
<span class="fc" id="L76">        private DataHandler dataHandler = null;</span>

        /**
         * Sets the initial size of the buffer that will be used to hold the data between top-level values. Default:
         * 32KB.
         *
         * @param initialBufferSizeInBytes the value.
         * @return this Builder.
         */
        public final BuilderType withInitialBufferSize(final int initialBufferSizeInBytes) {
<span class="fc" id="L86">            initialBufferSize = initialBufferSizeInBytes;</span>
<span class="fc" id="L87">            return (BuilderType) this;</span>
        }

        /**
         * @return the initial size of the lookahead buffer, in bytes.
         */
        public final int getInitialBufferSize() {
<span class="fc" id="L94">            return initialBufferSize;</span>
        }

        /**
         * Sets the handler that will be notified when oversized values are encountered. If the maximum buffer size is
         * finite (see {@link #withMaximumBufferSize(int)}, this handler is required to be non-null.
         *
         * @param handler the handler.
         * @return this builder.
         */
        public final BuilderType onOversizedValue(final OversizedValueHandler handler) {
<span class="fc" id="L105">            oversizedValueHandler = handler;</span>
<span class="fc" id="L106">            return (BuilderType) this;</span>
        }

        /**
         * Sets the handler that will be notified when data is processed. The handler may be null, in which case the
         * number of bytes processed will not be reported.
         *
         * @param handler the handler.
         * @return this builder.
         */
        public final BuilderType onData(final DataHandler handler) {
<span class="fc" id="L117">            dataHandler = handler;</span>
<span class="fc" id="L118">            return (BuilderType) this;</span>
        }

        /**
         * @return the handler that will be notified when oversized values are encountered.
         */
        public final OversizedValueHandler getOversizedValueHandler() {
<span class="fc" id="L125">            return oversizedValueHandler;</span>
        }

        /**
         * @return the handler that will be notified when data is processed.
         */
        public final DataHandler getDataHandler() {
<span class="fc" id="L132">            return dataHandler;</span>
        }

        /**
         * Set the maximum number of bytes between top-level values. This can be used to limit growth of the internal
         * buffer. For binary Ion, the minimum value is 5 because all valid binary Ion data begins with a 4-byte Ion
         * version marker and the smallest value is 1 byte. For delimited text Ion, the minimum value is 2 because the
         * smallest text Ion value is 1 byte and the smallest delimiter is 1 byte. Default: Integer.MAX_VALUE.
         *
         * @param maximumBufferSizeInBytes the value.
         * @return this builder.
         */
        public final BuilderType withMaximumBufferSize(final int maximumBufferSizeInBytes) {
<span class="fc" id="L145">            maximumBufferSize = maximumBufferSizeInBytes;</span>
<span class="fc" id="L146">            return (BuilderType) this;</span>
        }

        /**
         * @return the maximum number of bytes that will be buffered.
         */
        public int getMaximumBufferSize() {
<span class="fc" id="L153">            return maximumBufferSize;</span>
        }

        /**
         * Gets the minimum allowed maximum buffer size.
         * @return the value.
         */
        public abstract int getMinimumMaximumBufferSize();

        /**
         * @return the no-op {@link OversizedValueHandler} for the type of BufferConfiguration that this Builder builds.
         */
        public abstract OversizedValueHandler getNoOpOversizedValueHandler();

        /**
         * @return the no-op {@link DataHandler} for the type of BufferConfiguration that this Builder builds.
         */
        public abstract DataHandler getNoOpDataHandler();

        /**
         * Creates a new BufferConfiguration from the Builder's current settings.
         * @return a new instance.
         */
        public abstract Configuration build();
    }

    /**
     * The initial size of the lookahead buffer, in bytes.
     */
    private final int initialBufferSize;

    /**
     * The maximum number of bytes that will be buffered.
     */
    private final int maximumBufferSize;

    /**
     * The handler that will be notified when oversized values are encountered.
     */
    private final OversizedValueHandler oversizedValueHandler;

    /**
     * The handler that will be notified when data is processed.
     */
    private final DataHandler dataHandler;

    /**
     * Constructs an instance from the given Builder.
     * @param builder the builder containing the settings to apply to the new configuration.
     */
<span class="fc" id="L203">    protected BufferConfiguration(Builder&lt;Configuration, ?&gt; builder) {</span>
<span class="fc" id="L204">        initialBufferSize = builder.getInitialBufferSize();</span>
<span class="fc" id="L205">        maximumBufferSize = builder.getMaximumBufferSize();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (initialBufferSize &gt; maximumBufferSize) {</span>
<span class="fc" id="L207">            throw new IllegalArgumentException(&quot;Initial buffer size may not exceed the maximum buffer size.&quot;);</span>
        }
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (maximumBufferSize &lt; builder.getMinimumMaximumBufferSize()) {</span>
<span class="fc" id="L210">            throw new IllegalArgumentException(String.format(</span>
<span class="fc" id="L211">                &quot;Maximum buffer size must be at least %d bytes.&quot;, builder.getMinimumMaximumBufferSize()</span>
            ));
        }
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (builder.getOversizedValueHandler() == null) {</span>
<span class="fc" id="L215">            requireUnlimitedBufferSize();</span>
<span class="fc" id="L216">            oversizedValueHandler = builder.getNoOpOversizedValueHandler();</span>
        } else {
<span class="fc" id="L218">            oversizedValueHandler = builder.getOversizedValueHandler();</span>
        }
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (builder.getDataHandler() == null) {</span>
<span class="fc" id="L221">            dataHandler = builder.getNoOpDataHandler();</span>
        } else {
<span class="fc" id="L223">            dataHandler = builder.getDataHandler();</span>
        }
<span class="fc" id="L225">    }</span>

    /**
     * Requires that the maximum buffer size not be limited.
     */
    protected void requireUnlimitedBufferSize() {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (maximumBufferSize &lt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L232">            throw new IllegalArgumentException(</span>
                &quot;Must specify an OversizedValueHandler when a maximum buffer size is specified.&quot;
            );
        }
<span class="fc" id="L236">    }</span>

    /**
     * @return the initial size of the lookahead buffer, in bytes.
     */
    public final int getInitialBufferSize() {
<span class="fc" id="L242">        return initialBufferSize;</span>
    }

    /**
     * @return the maximum number of bytes that will be buffered.
     */
    public final int getMaximumBufferSize() {
<span class="fc" id="L249">        return maximumBufferSize;</span>
    }

    /**
     * @return the handler that will be notified when oversized values are encountered.
     */
    public final OversizedValueHandler getOversizedValueHandler() {
<span class="fc" id="L256">        return oversizedValueHandler;</span>
    }

    /**
     * @return the handler that will be notified when data is processed.
     */
    public final DataHandler getDataHandler() {
<span class="fc" id="L263">        return dataHandler;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>