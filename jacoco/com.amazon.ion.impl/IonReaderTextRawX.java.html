<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderTextRawX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderTextRawX.java</span></div><h1>IonReaderTextRawX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static com.amazon.ion.impl.IonTokenConstsX.TOKEN_CLOSE_BRACE;
import static com.amazon.ion.impl.IonTokenConstsX.TOKEN_CLOSE_PAREN;
import static com.amazon.ion.impl.IonTokenConstsX.TOKEN_CLOSE_SQUARE;

import com.amazon.ion.IonException;
import com.amazon.ion.IonTextReader;
import com.amazon.ion.IonType;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.UnknownSymbolException;
import com.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;
import com.amazon.ion.impl._Private_ScalarConversions.AS_TYPE;
import com.amazon.ion.impl._Private_ScalarConversions.ValueVariant;
import java.io.IOException;
import java.math.BigInteger;
import java.util.Iterator;

/**
 * Reader implementation that reads the token stream and validates
 * the Ion grammar.  This does not care about system values.  It
 * does not materialize values or convert them.  It does mark values
 * in the UnifiedInputStream if they might be field names or annotations
 * since it does populate these properties directly. Otherwise it
 * accepts the TextRawToken's assessment of the type of the next
 * token, which is based on as few characters as possible, typically
 * 1 but generally less than 5.
 *
 * This is called by the {@link IonReaderTextSystemX}, which in turn is most
 * often called by the {@link IonReaderTextUserX}.  One of these two (system
 * reader or user reader) should be invoked by the user for reading text Ion
 * data.  This class is not intended for general use.
 *
 * This reader scan skip values and in doing so it does not
 * materialize the contents and it does not validate the contents.
 * TODO amzn/ion-java/issues/7 We may want to make validation on skip optional.
 *
 * This manages the value buffer (_v ValueVariant) and the lob
 * content (_lob_*) which is cached in some cases.  It's main
 * job however is recognizing the correct order of the input
 * tokens.  This is done in parse_to_next_value (called by hasNext).
 *
 * The current state is represented by an int (whose value should
 * be one of the values of the STATE_* constants).  The legal
 * transitions are stored in TransitionActions and TransitionActions2.
 * The first (TransitionActions) is a two dimensional array whose
 * dimensions are state and input token. The value stored is an
 * int that represents the action to be taken (ACTION_*).  The
 * second copy of this data (TransitionActions2) is a one dimensional
 * array built from the first and manually dereferenced in the
 * parse_to_next_value method.  This turns out to be a significant
 * performance gain (&lt;sigh&gt;).  Logically these are the same.
 *
 */
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">abstract class IonReaderTextRawX</span>
    implements IonTextReader
{
    public abstract BigInteger bigIntegerValue();

//              static final boolean _object_parser           = false;
              static final boolean _debug                   = false;
    private   static final int     DEFAULT_STACK_DEPTH      = 10;
    protected static final int     UNKNOWN_SIZE             = -1;
    private   static final int     DEFAULT_ANNOTATION_COUNT =  5;

    static final int STATE_BEFORE_ANNOTATION_DATAGRAM     =  0;
    static final int STATE_BEFORE_ANNOTATION_CONTAINED    =  1;
    static final int STATE_BEFORE_ANNOTATION_SEXP         =  2;
    static final int STATE_BEFORE_FIELD_NAME              =  3;
    static final int STATE_BEFORE_VALUE_CONTENT           =  4;
    static final int STATE_BEFORE_VALUE_CONTENT_SEXP      =  5;
    static final int STATE_IN_LONG_STRING                 =  6;
    static final int STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT  =  7;
    static final int STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT  =  8;
    static final int STATE_IN_BLOB_CONTENT                =  9;
    static final int STATE_AFTER_VALUE_CONTENTS           = 10;
    static final int STATE_EOF                            = 11;
    static final int STATE_MAX                            = 11;
    private final String get_state_name(int state) {
<span class="pc bpc" id="L97" title="7 of 13 branches missed.">        switch(state) {</span>
<span class="fc" id="L98">        case STATE_BEFORE_ANNOTATION_DATAGRAM:    return &quot;STATE_BEFORE_ANNOTATION_DATAGRAM&quot;;</span>
<span class="fc" id="L99">        case STATE_BEFORE_ANNOTATION_CONTAINED:   return &quot;STATE_BEFORE_ANNOTATION_CONTAINED&quot;;</span>
<span class="fc" id="L100">        case STATE_BEFORE_ANNOTATION_SEXP:        return &quot;STATE_BEFORE_ANNOTATION_SEXP&quot;;</span>
<span class="fc" id="L101">        case STATE_BEFORE_FIELD_NAME:             return &quot;STATE_BEFORE_FIELD_NAME&quot;;</span>
<span class="fc" id="L102">        case STATE_BEFORE_VALUE_CONTENT:          return &quot;STATE_BEFORE_VALUE_CONTENT&quot;;</span>
<span class="nc" id="L103">        case STATE_BEFORE_VALUE_CONTENT_SEXP:     return &quot;STATE_BEFORE_VALUE_CONTENT_SEXP&quot;;</span>
<span class="nc" id="L104">        case STATE_IN_LONG_STRING:                return &quot;STATE_IN_LONG_STRING&quot;;</span>
<span class="nc" id="L105">        case STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT: return &quot;STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT&quot;;</span>
<span class="nc" id="L106">        case STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT: return &quot;STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT&quot;;</span>
<span class="nc" id="L107">        case STATE_IN_BLOB_CONTENT:               return &quot;STATE_IN_BLOB_CONTENT&quot;;</span>
<span class="fc" id="L108">        case STATE_AFTER_VALUE_CONTENTS:          return &quot;STATE_AFTER_VALUE_CONTENTS&quot;;</span>
<span class="nc" id="L109">        case STATE_EOF:                           return &quot;STATE_EOF&quot;;</span>
<span class="nc" id="L110">        default:                                  return &quot;&lt;invalid state: &quot;+Integer.toString(state)+&quot;&gt;&quot;;</span>
        }
    }

    static final int ACTION_NOT_DEFINED          =  0;
    static final int ACTION_LOAD_FIELD_NAME      =  1;
    static final int ACTION_LOAD_ANNOTATION      =  2;
    static final int ACTION_START_STRUCT         =  3;
    static final int ACTION_START_LIST           =  4;
    static final int ACTION_START_SEXP           =  5;
    static final int ACTION_START_LOB            =  6;
    static final int ACTION_LOAD_SCALAR          =  8;
    static final int ACTION_PLUS_INF             =  9;
    static final int ACTION_MINUS_INF            = 10;
    static final int ACTION_EAT_COMMA            = 11; // if this is unnecessary (because load_scalar handle it) we don't need &quot;after_value&quot;
    static final int ACTION_FINISH_CONTAINER     = 12;
    static final int ACTION_FINISH_LOB           = 13;
    static final int ACTION_FINISH_DATAGRAM      = 14;
    static final int ACTION_EOF                  = 15;
    static final int ACTION_count                = 16;
    @SuppressWarnings(&quot;unused&quot;)
    private final String get_action_name(int action) {
<span class="nc bnc" id="L132" title="All 16 branches missed.">        switch(action) {</span>
<span class="nc" id="L133">        case ACTION_NOT_DEFINED:        return &quot;ACTION_DO_NOTHING&quot;;</span>
<span class="nc" id="L134">        case ACTION_LOAD_FIELD_NAME:    return &quot;ACTION_LOAD_FIELD_NAME&quot;;</span>
<span class="nc" id="L135">        case ACTION_LOAD_ANNOTATION:    return &quot;ACTION_LOAD_ANNOTATION&quot;;</span>
<span class="nc" id="L136">        case ACTION_START_STRUCT:       return &quot;ACTION_START_STRUCT&quot;;</span>
<span class="nc" id="L137">        case ACTION_START_LIST:         return &quot;ACTION_START_LIST&quot;;</span>
<span class="nc" id="L138">        case ACTION_START_SEXP:         return &quot;ACTION_START_SEXP&quot;;</span>
<span class="nc" id="L139">        case ACTION_START_LOB:          return &quot;ACTION_START_LOB&quot;;</span>
<span class="nc" id="L140">        case ACTION_LOAD_SCALAR:        return &quot;ACTION_LOAD_SCALAR&quot;;</span>
<span class="nc" id="L141">        case ACTION_PLUS_INF:           return &quot;ACTION_PLUS_INF&quot;;</span>
<span class="nc" id="L142">        case ACTION_MINUS_INF:          return &quot;ACTION_MINUS_INF&quot;;</span>
<span class="nc" id="L143">        case ACTION_EAT_COMMA:          return &quot;ACTION_EAT_COMMA&quot;;</span>
<span class="nc" id="L144">        case ACTION_FINISH_CONTAINER:   return &quot;ACTION_FINISH_CONTAINER&quot;;</span>
<span class="nc" id="L145">        case ACTION_FINISH_LOB:         return &quot;ACTION_FINISH_LOB&quot;;</span>
<span class="nc" id="L146">        case ACTION_FINISH_DATAGRAM:    return &quot;ACTION_FINISH_DATAGRAM&quot;;</span>
<span class="nc" id="L147">        case ACTION_EOF:                return &quot;ACTION_EOF&quot;;</span>
<span class="nc" id="L148">        default:                        return &quot;&lt;unrecognized action: &quot;+Integer.toString(action)+&quot;&gt;&quot;;</span>
        }
    }

<span class="fc" id="L152">    static final int[][] TransitionActions = makeTransitionActionArray();</span>
    static final int[][] makeTransitionActionArray()
    {
<span class="fc" id="L155">        int[][] actions = new int[STATE_MAX + 1][IonTokenConstsX.TOKEN_MAX + 1];</span>

<span class="fc" id="L157">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_EOF]                = ACTION_FINISH_DATAGRAM;</span>
<span class="fc" id="L158">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC]    = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L159">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_INT]                = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L160">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_BINARY]             = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L161">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_HEX]                = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L162">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_DECIMAL]            = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L163">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_FLOAT]              = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L164">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_FLOAT_INF]          = ACTION_PLUS_INF;</span>
<span class="fc" id="L165">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_FLOAT_MINUS_INF]    = ACTION_MINUS_INF;</span>
<span class="fc" id="L166">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_TIMESTAMP]          = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L167">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE]= ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L168">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE]= ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L169">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]  = ACTION_LOAD_ANNOTATION;</span>
<span class="fc" id="L170">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]      = ACTION_LOAD_ANNOTATION;</span>
<span class="fc" id="L171">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_PAREN]         = ACTION_START_SEXP;</span>
<span class="fc" id="L172">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_BRACE]         = ACTION_START_STRUCT;</span>
<span class="fc" id="L173">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_SQUARE]        = ACTION_START_LIST;</span>
<span class="fc" id="L174">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE]  = ACTION_START_LOB;</span>

        // both before_annotation and after_annotation are essentially the same as
        // BOF (after_annotation can't accept EOF as valid however)
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (int ii=0; ii&lt;IonTokenConstsX.TOKEN_MAX+1; ii++) {</span>
<span class="fc" id="L179">            actions[STATE_BEFORE_ANNOTATION_CONTAINED][ii] = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
<span class="fc" id="L180">            actions[STATE_BEFORE_ANNOTATION_SEXP][ii]      = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
<span class="fc" id="L181">            actions[STATE_BEFORE_VALUE_CONTENT][ii]        = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
<span class="fc" id="L182">            actions[STATE_BEFORE_VALUE_CONTENT_SEXP][ii]   = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
        }
        // now patch up the differences between these 4 states handling of tokens vs before_annotation_datagram
<span class="fc" id="L185">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_EOF]            = 0;</span>
<span class="fc" id="L186">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_CLOSE_PAREN]    = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L187">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_CLOSE_BRACE]    = 0;</span>
<span class="fc" id="L188">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_CLOSE_SQUARE]   = ACTION_FINISH_CONTAINER;</span>

<span class="fc" id="L190">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_EOF]                 = 0;</span>
<span class="fc" id="L191">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_SYMBOL_OPERATOR]     = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L192">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_DOT]                 = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L193">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_CLOSE_PAREN]         = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L194">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_CLOSE_BRACE]         = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L195">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_CLOSE_SQUARE]        = ACTION_FINISH_CONTAINER;</span>

<span class="fc" id="L197">        actions[STATE_BEFORE_VALUE_CONTENT][IonTokenConstsX.TOKEN_EOF]                   = 0;</span>
<span class="fc" id="L198">        actions[STATE_BEFORE_VALUE_CONTENT][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]     = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L199">        actions[STATE_BEFORE_VALUE_CONTENT][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]         = ACTION_LOAD_SCALAR;</span>

<span class="fc" id="L201">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_EOF]              = 0;</span>
<span class="fc" id="L202">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]= ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L203">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]    = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L204">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_SYMBOL_OPERATOR]  = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L205">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_DOT]              = ACTION_LOAD_SCALAR;</span>

<span class="fc" id="L207">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_EOF]                      = 0;</span>
<span class="fc" id="L208">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]        = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L209">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]            = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L210">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE]      = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L211">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE]      = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L212">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_CLOSE_PAREN]              = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L213">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_CLOSE_BRACE]              = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L214">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_CLOSE_SQUARE]             = ACTION_FINISH_CONTAINER;</span>

         // after a value we'll either see a separator (like ',')
         // or a containers closing token. If we're not in a container
         // (i.e. we're at the top level) then this isn't the state we
         // should be in.  We'll be in STATE_BEFORE_ANNOTATION_DATAGRAM
<span class="fc" id="L220">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_COMMA]                = ACTION_EAT_COMMA;</span>
<span class="fc" id="L221">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_CLOSE_PAREN]          = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L222">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_CLOSE_BRACE]          = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L223">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_CLOSE_SQUARE]         = ACTION_FINISH_CONTAINER;</span>

         // the three &quot;in_&lt;lob&gt;&quot; value states have to be handled
         // specially, they can only scan forward to the end of
         // the content on next, or read content for the user otherwise
<span class="fc" id="L228">         actions[STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT][IonTokenConstsX.TOKEN_CLOSE_BRACE] = ACTION_FINISH_LOB;</span>
<span class="fc" id="L229">         actions[STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT][IonTokenConstsX.TOKEN_CLOSE_BRACE] = ACTION_FINISH_LOB;</span>
<span class="fc" id="L230">         actions[STATE_IN_BLOB_CONTENT][IonTokenConstsX.TOKEN_CLOSE_BRACE]               = ACTION_FINISH_LOB;</span>

         // the eof action exists because finishing an unread value can place the scanner just before
         // the input stream eof and set the current state to eof - in which case we just need to return eof
<span class="fc bfc" id="L234" title="All 2 branches covered.">         for (int ii=0; ii&lt;IonTokenConstsX.TOKEN_MAX+1; ii++) {</span>
<span class="fc" id="L235">             actions[STATE_EOF][ii] =  ACTION_EOF;</span>
         }

<span class="fc" id="L238">         return actions;</span>
    }

<span class="fc" id="L241">    static final int[] TransitionActions2 = makeTransition2ActionArray();</span>
    static int[] makeTransition2ActionArray() {
<span class="fc" id="L243">        int   s, s_count = STATE_MAX + 1;</span>
<span class="fc" id="L244">        int   t, t_count = IonTokenConstsX.TOKEN_MAX + 1;</span>
<span class="fc" id="L245">        int[] a = new int[s_count * t_count];</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (s = 0; s &lt; s_count; s++) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            for (t=0; t &lt; t_count; t++) {</span>
<span class="fc" id="L248">                int ii = s * IonTokenConstsX.TOKEN_count + t;</span>
<span class="fc" id="L249">                a[ii] = TransitionActions[s][t];</span>
            }
        }
<span class="fc" id="L252">        return a;</span>
    }

    //
    //  actual class members (preceding values are just parsing
    //  control constants).
    //

    IonReaderTextRawTokensX  _scanner;

    boolean             _eof;
    int                 _state;

<span class="fc" id="L265">    IonType[]           _container_state_stack = new IonType[DEFAULT_STACK_DEPTH];</span>
    int                 _container_state_top;
    boolean             _container_is_struct;           // helper bool's set on push and pop and used
    boolean             _container_prohibits_commas;    // frequently during state transitions actions

    boolean             _has_next_called;
    IonType             _value_type;
    int                 _value_keyword;
    IonType             _null_type;
    String              _field_name;
<span class="fc" id="L275">    int                 _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
    int                 _annotation_count;
    SymbolToken[]    _annotations;

    boolean             _current_value_save_point_loaded;
    SavePoint           _current_value_save_point;
    boolean             _current_value_buffer_loaded;
    StringBuilder       _current_value_buffer;

<span class="fc" id="L284">    ValueVariant        _v = new ValueVariant();</span>

    long                _value_start_offset;
    long                _value_start_line;
    long                _value_start_column;
    IonType             _nesting_parent;

<span class="fc" id="L291">    enum LOB_STATE { EMPTY, READ, FINISHED }</span>
    boolean             _lob_value_set;
    int                 _lob_token;
    long                _lob_value_position;
    LOB_STATE           _lob_loaded;
    byte[]              _lob_bytes;
    int                 _lob_actual_len;


    protected IonReaderTextRawX() {
<span class="fc" id="L301">        super();</span>
<span class="fc" id="L302">        _nesting_parent = null;</span>
<span class="fc" id="L303">    }</span>


    /**
     * @return This implementation always returns null.
     */
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="fc" id="L311">        return null;</span>
    }

    //========================================================================

    protected final void init_once() {
<span class="fc" id="L317">        _current_value_buffer = new StringBuilder();</span>
<span class="fc" id="L318">        _annotations = new SymbolToken[DEFAULT_ANNOTATION_COUNT];</span>
<span class="fc" id="L319">    }</span>

    protected final void init(UnifiedInputStreamX iis, IonType parent)
    {
<span class="fc" id="L323">        init(iis, parent, 1, 1);</span>
<span class="fc" id="L324">    }</span>

    protected final void init(UnifiedInputStreamX iis
                             ,IonType parent
                             ,long start_line
                             ,long start_column
    ) {

<span class="pc bpc" id="L332" title="2 of 4 branches missed.">        assert(parent != null);</span>
<span class="fc" id="L333">        _scanner = new IonReaderTextRawTokensX(iis, start_line, start_column);</span>
<span class="fc" id="L334">        _value_start_line = start_line;</span>
<span class="fc" id="L335">        _value_start_column = start_column;</span>
<span class="fc" id="L336">        _current_value_save_point = iis.savePointAllocate();</span>
<span class="fc" id="L337">        _lob_loaded = LOB_STATE.EMPTY;</span>
<span class="fc" id="L338">        int starting_state = get_state_at_container_start(parent);</span>
<span class="fc" id="L339">        set_state(starting_state);</span>
<span class="fc" id="L340">        _eof = false;</span>
<span class="fc" id="L341">        push_container_state(parent);</span>
<span class="fc" id="L342">    }</span>

    protected final void re_init(UnifiedInputStreamX iis
                                ,IonType parent
                                ,long start_line
                                ,long start_column
    ) {
<span class="fc" id="L349">        _state = 0;</span>
<span class="fc" id="L350">        _container_state_top = 0;</span>
<span class="fc" id="L351">        _container_is_struct = false;</span>
<span class="fc" id="L352">        _container_prohibits_commas = false;</span>
<span class="fc" id="L353">        _has_next_called = false;</span>
<span class="fc" id="L354">        _value_type = null;</span>
<span class="fc" id="L355">        _value_keyword = 0;</span>
<span class="fc" id="L356">        _null_type = null;</span>
<span class="fc" id="L357">        _field_name = null;</span>
<span class="fc" id="L358">        _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L359">        _annotation_count = 0;</span>
<span class="fc" id="L360">        _current_value_save_point_loaded = false;</span>
<span class="fc" id="L361">        _current_value_buffer_loaded = false;</span>
<span class="fc" id="L362">        _value_start_offset = 0;</span>
<span class="fc" id="L363">        _lob_value_set = false;</span>
<span class="fc" id="L364">        _lob_token = 0;</span>
<span class="fc" id="L365">        _lob_value_position = 0;</span>
<span class="fc" id="L366">        _lob_bytes = null;</span>
<span class="fc" id="L367">        _lob_actual_len = 0;</span>

<span class="fc" id="L369">        init(iis, parent, start_line, start_column);</span>

<span class="fc" id="L371">        _nesting_parent = parent;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (IonType.STRUCT.equals(_nesting_parent)) {</span>
<span class="fc" id="L373">            _container_is_struct = true;</span>
        }
<span class="fc" id="L375">    }</span>

    public void close()
        throws IOException
    {
<span class="fc" id="L380">        _scanner.close();</span>
<span class="fc" id="L381">    }</span>

    private final void set_state(int new_state) {
<span class="fc" id="L384">        _state = new_state;</span>
<span class="fc" id="L385">    }</span>
    private final int get_state_int() {
<span class="fc" id="L387">        return _state;</span>
    }
    private final String get_state_name() {
<span class="fc" id="L390">        String name = get_state_name(get_state_int());</span>
<span class="fc" id="L391">        return name;</span>
    }

    protected final void clear_current_value_buffer() {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (_current_value_buffer_loaded) {</span>
<span class="fc" id="L396">            _current_value_buffer.setLength(0);</span>
<span class="fc" id="L397">            _current_value_buffer_loaded = false;</span>
        }
<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (_current_value_save_point_loaded) {</span>
<span class="fc" id="L400">            _current_value_save_point.clear();</span>
<span class="fc" id="L401">            _current_value_save_point_loaded = false;</span>
        }
<span class="fc" id="L403">    }</span>

    private final void current_value_is_null(IonType null_type)
    {
<span class="fc" id="L407">        clear_current_value_buffer();</span>
<span class="fc" id="L408">        _value_type = _null_type;</span>
<span class="fc" id="L409">        _v.setValueToNull(null_type);</span>
<span class="fc" id="L410">        _v.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.null_value);</span>
<span class="fc" id="L411">    }</span>

    private final void current_value_is_bool(boolean value)
    {
<span class="fc" id="L415">        clear_current_value_buffer();</span>
<span class="fc" id="L416">        _value_type = IonType.BOOL;</span>
<span class="fc" id="L417">        _v.setValue(value);</span>
<span class="fc" id="L418">        _v.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.boolean_value);</span>
<span class="fc" id="L419">    }</span>

    private final void set_fieldname(SymbolToken sym) {
<span class="fc" id="L422">        _field_name = sym.getText();</span>
<span class="fc" id="L423">        _field_name_sid = sym.getSid();</span>
<span class="fc" id="L424">    }</span>

    private final void clear_fieldname() {
<span class="fc" id="L427">        _field_name = null;</span>
<span class="fc" id="L428">        _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L429">    }</span>

    private final void append_annotation(SymbolToken sym) {
        // empty text is checked by caller
<span class="fc" id="L433">        int oldlen = _annotations.length;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (_annotation_count &gt;= oldlen) {</span>
<span class="fc" id="L435">            int newlen = oldlen * 2;</span>
<span class="fc" id="L436">            SymbolToken[] temp = new SymbolToken[newlen];</span>
<span class="fc" id="L437">            System.arraycopy(_annotations, 0, temp, 0, oldlen);</span>
<span class="fc" id="L438">            _annotations = temp;</span>
        }
<span class="fc" id="L440">        _annotations[_annotation_count++] = sym;</span>
<span class="fc" id="L441">    }</span>

    private final void clear_annotation_list() {
<span class="fc" id="L444">        _annotation_count = 0;</span>
<span class="fc" id="L445">    }</span>

    /**
     * this looks forward to see if there is an upcoming value
     * if there is it returns true.  It may have to clean up
     * any value that's partially complete (for example a
     * collection whose annotation has been read and loaded
     * but the user has chosen not to step into the collection).
     * @return true if more data remains, false on eof
     */
    public boolean hasNext()
    {
<span class="fc" id="L457">        boolean has_next = has_next_raw_value();</span>
<span class="fc" id="L458">        return has_next;</span>
    }
    protected final boolean has_next_raw_value() {
<span class="pc bpc" id="L461" title="1 of 4 branches missed.">        if (!_has_next_called &amp;&amp; !_eof) {</span>
            try {
<span class="fc" id="L463">                finish_value(null);</span>
<span class="fc" id="L464">                clear_value();</span>
<span class="fc" id="L465">                parse_to_next_value();</span>
            }
<span class="fc" id="L467">            catch (IOException e) {</span>
<span class="fc" id="L468">                throw new IonException(e);</span>
<span class="fc" id="L469">            }</span>
<span class="fc" id="L470">            _has_next_called = true;</span>
        }
<span class="fc bfc" id="L472" title="All 2 branches covered.">        return (_eof != true);</span>
    }

    /**
     * returns the type of the next value in the stream.
     * it calls hasNext to assure that the value has been properly
     * started, since hasNext prepares a value as a side effect of
     * determining whether or not a value is pending.
     * A NoSuchElementException is thrown if there are not values remaining.
     * Once called if there is a value available it's contents can
     * be accessed through the other public API's (such as getLong()).
     * @return type of the next value, or null if there is none.
     */
    public IonType next()
    {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L488">            return null;</span>
        }
<span class="pc bpc" id="L490" title="1 of 4 branches missed.">        if (_value_type == null &amp;&amp; _scanner.isUnfinishedToken()) {</span>
            try {
<span class="fc" id="L492">                token_contents_load(_scanner.getToken());</span>
            }
<span class="nc" id="L494">            catch (IOException e) {</span>
<span class="nc" id="L495">                throw new IonException(e);</span>
<span class="fc" id="L496">            }</span>
        }
<span class="fc" id="L498">        _has_next_called = false;</span>
<span class="fc" id="L499">        return _value_type;</span>
    }
    private final void finish_and_save_value() throws IOException
    {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (!_current_value_save_point_loaded) {</span>
<span class="fc" id="L504">            _scanner.save_point_start(_current_value_save_point);</span>
<span class="fc" id="L505">            finish_value(_current_value_save_point);</span>
<span class="fc" id="L506">            _current_value_save_point_loaded = true;</span>
        }
<span class="fc" id="L508">    }</span>
    private final void finish_value(SavePoint sp) throws IOException
    {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (_scanner.isUnfinishedToken()) {</span>
<span class="pc bpc" id="L512" title="1 of 4 branches missed.">            if (sp != null &amp;&amp; _value_type != null) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                switch (_value_type) {</span>
                case STRUCT:
                case SEXP:
                case LIST:
<span class="nc" id="L517">                    sp = null;</span>
<span class="nc" id="L518">                    break;</span>
                default:
                    break;
                }
            }
<span class="fc" id="L523">            _scanner.finish_token(sp);</span>

<span class="fc" id="L525">            int new_state = get_state_after_value();</span>
<span class="fc" id="L526">            set_state(new_state);</span>
        }
<span class="fc" id="L528">        _has_next_called = false;</span>
<span class="fc" id="L529">    }</span>
    private final void clear_value()
    {
<span class="fc" id="L532">        _value_type = null;</span>
<span class="fc" id="L533">        _null_type = null;</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (_lob_value_set) {</span>
<span class="nc" id="L535">            _lob_value_set = false;</span>
<span class="nc" id="L536">            _lob_value_position = 0;</span>
        }
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (!LOB_STATE.EMPTY.equals(_lob_loaded)) {</span>
<span class="fc" id="L539">            _lob_actual_len = -1;</span>
<span class="fc" id="L540">            _lob_bytes = null;</span>
<span class="fc" id="L541">            _lob_loaded = LOB_STATE.EMPTY;</span>
        }
<span class="fc" id="L543">        clear_current_value_buffer();</span>
<span class="fc" id="L544">        clear_annotation_list();</span>
<span class="fc" id="L545">        clear_fieldname();</span>
<span class="fc" id="L546">        _v.clear();</span>
<span class="fc" id="L547">        _value_start_offset = -1;</span>
<span class="fc" id="L548">    }</span>

    private final void set_container_flags(IonType t) {
<span class="pc bpc" id="L551" title="1 of 5 branches missed.">        switch (t) {</span>
        case LIST:
<span class="fc" id="L553">            _container_is_struct = false;</span>
<span class="fc" id="L554">            _container_prohibits_commas = false;</span>
<span class="fc" id="L555">            break;</span>
        case SEXP:
<span class="fc" id="L557">            _container_is_struct = false;</span>
<span class="fc" id="L558">            _container_prohibits_commas = true;</span>
<span class="fc" id="L559">            break;</span>
        case STRUCT:
<span class="fc" id="L561">            _container_is_struct = true;</span>
<span class="fc" id="L562">            _container_prohibits_commas = false;</span>
<span class="fc" id="L563">            break;</span>
        case DATAGRAM:
<span class="fc" id="L565">            _container_is_struct = false;</span>
<span class="fc" id="L566">            _container_prohibits_commas = true;</span>
<span class="fc" id="L567">            break;</span>
        default:
<span class="nc" id="L569">            throw new IllegalArgumentException(&quot;type must be a container, not a &quot;+t.toString());</span>
        }
<span class="fc" id="L571">    }</span>

    private int get_state_after_value()
    {
        int state_after_scalar;
<span class="pc bpc" id="L576" title="1 of 4 branches missed.">        switch(getContainerType()) {</span>
        case LIST:
        case STRUCT:
<span class="fc" id="L579">            state_after_scalar = STATE_AFTER_VALUE_CONTENTS;</span>
<span class="fc" id="L580">            break;</span>
        case SEXP:
<span class="fc" id="L582">            state_after_scalar = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L583">            break;</span>
        case DATAGRAM:
<span class="fc" id="L585">            state_after_scalar = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
<span class="fc" id="L586">            break;</span>
        default:
<span class="nc" id="L588">            String message = &quot;invalid container type encountered during parsing &quot;</span>
<span class="nc" id="L589">                           + getContainerType()</span>
<span class="nc" id="L590">                           + _scanner.input_position();</span>
<span class="nc" id="L591">            throw new IonException(message);</span>
        }
<span class="fc bfc" id="L593" title="All 4 branches covered.">        if (_nesting_parent != null &amp;&amp; getDepth() == 0) {</span>
<span class="fc" id="L594">            state_after_scalar = STATE_EOF;</span>
        }
<span class="fc" id="L596">        return state_after_scalar;</span>
    }
    private final int get_state_after_annotation() {
        int state_after_annotation;
<span class="pc bpc" id="L600" title="2 of 4 branches missed.">        switch(get_state_int()) {</span>
        case STATE_AFTER_VALUE_CONTENTS:
<span class="nc" id="L602">            IonType container = top_state();</span>
<span class="nc bnc" id="L603" title="All 3 branches missed.">            switch(container) {</span>
            case STRUCT:
            case LIST:
            case DATAGRAM:
<span class="nc" id="L607">                state_after_annotation = STATE_BEFORE_VALUE_CONTENT;</span>
<span class="nc" id="L608">                break;</span>
            case SEXP:
<span class="nc" id="L610">                state_after_annotation = STATE_BEFORE_VALUE_CONTENT_SEXP;</span>
<span class="nc" id="L611">                break;</span>
            default:
<span class="nc" id="L613">                String message = &quot;invalid container type encountered during parsing &quot;</span>
                    + container
<span class="nc" id="L615">                    + _scanner.input_position();</span>
<span class="nc" id="L616">                throw new IonException(message);</span>
            }
<span class="nc" id="L618">            break;</span>
        case STATE_BEFORE_ANNOTATION_DATAGRAM:
        case STATE_BEFORE_ANNOTATION_CONTAINED:
<span class="fc" id="L621">            state_after_annotation = STATE_BEFORE_VALUE_CONTENT;</span>
<span class="fc" id="L622">            break;</span>
        case STATE_BEFORE_ANNOTATION_SEXP:
<span class="fc" id="L624">            state_after_annotation = STATE_BEFORE_VALUE_CONTENT_SEXP;</span>
<span class="fc" id="L625">            break;</span>
        default:
<span class="nc" id="L627">            String message = &quot;invalid state encountered during parsing before the value &quot;</span>
<span class="nc" id="L628">                + get_state_name()</span>
<span class="nc" id="L629">                + _scanner.input_position();</span>
<span class="nc" id="L630">            throw new IonException(message);</span>
        }
<span class="fc" id="L632">        return state_after_annotation;</span>
    }

    private final int get_state_after_container() {
<span class="fc" id="L636">        IonType container = top_state();</span>
<span class="fc" id="L637">        int new_state = get_state_after_container(container);</span>
<span class="fc" id="L638">        return new_state;</span>
    }

    private final int get_state_after_container(int token) {
<span class="fc" id="L642">        IonType container = top_state();</span>

<span class="pc bpc" id="L644" title="1 of 4 branches missed.">        switch(container) {</span>
            case STRUCT:
<span class="fc" id="L646">                check_container_close(container, TOKEN_CLOSE_BRACE, token);</span>
<span class="fc" id="L647">                break;</span>
            case LIST:
<span class="fc" id="L649">                check_container_close(container, TOKEN_CLOSE_SQUARE, token);</span>
<span class="fc" id="L650">                break;</span>
            case SEXP:
<span class="fc" id="L652">                check_container_close(container, TOKEN_CLOSE_PAREN, token);</span>
<span class="fc" id="L653">                break;</span>
            case DATAGRAM:
                // We shouldn't get here.  Fall through.
            default:
<span class="nc" id="L657">                String message = &quot;invalid container type encountered during parsing &quot;</span>
                    + container
<span class="nc" id="L659">                    + _scanner.input_position();</span>
<span class="nc" id="L660">                throw new IonException(message);</span>
        }

<span class="fc" id="L663">        int new_state = get_state_after_container(container);</span>
<span class="fc" id="L664">        return new_state;</span>
    }

    private final int get_state_after_container(IonType container) {
        int new_state;
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (container == null) {</span>
<span class="nc" id="L670">            new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
        }
        else {
<span class="pc bpc" id="L673" title="1 of 4 branches missed.">            switch(container) {</span>
                case STRUCT:
                case LIST:
<span class="fc" id="L676">                    new_state = STATE_AFTER_VALUE_CONTENTS;</span>
<span class="fc" id="L677">                    break;</span>
                case SEXP:
<span class="fc" id="L679">                    new_state = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L680">                    break;</span>
                case DATAGRAM:
<span class="fc" id="L682">                    new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
<span class="fc" id="L683">                    break;</span>
                default:
<span class="nc" id="L685">                    String message = &quot;invalid container type encountered during parsing &quot;</span>
                        + container
<span class="nc" id="L687">                        + _scanner.input_position();</span>
<span class="nc" id="L688">                    throw new IonException(message);</span>
            }
<span class="fc bfc" id="L690" title="All 4 branches covered.">            if (_nesting_parent != null &amp;&amp; getDepth() == 0) {</span>
<span class="fc" id="L691">                new_state = STATE_EOF;</span>
            }
        }
<span class="fc" id="L694">        return new_state;</span>
    }

    private final void check_container_close(IonType container, int expectedToken, int actualToken)
    {
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (actualToken != expectedToken) {</span>
<span class="fc" id="L700">            String message = container.toString().toLowerCase() + &quot; closed by &quot;</span>
<span class="fc" id="L701">                + IonTokenConstsX.describeToken(actualToken)</span>
<span class="fc" id="L702">                + _scanner.input_position();</span>
<span class="fc" id="L703">            throw new IonException(message);</span>
        }
<span class="fc" id="L705">    }</span>

    private final int get_state_at_container_start(IonType container) {
        int new_state;
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if (container == null) {</span>
<span class="nc" id="L710">            new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
        }
        else {
<span class="pc bpc" id="L713" title="1 of 5 branches missed.">            switch (container) {</span>
            case STRUCT:
<span class="fc" id="L715">                new_state = STATE_BEFORE_FIELD_NAME;</span>
<span class="fc" id="L716">                break;</span>
            case LIST:
<span class="fc" id="L718">                new_state = STATE_BEFORE_ANNOTATION_CONTAINED;</span>
<span class="fc" id="L719">                break;</span>
            case SEXP:
<span class="fc" id="L721">                new_state = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L722">                break;</span>
            case DATAGRAM:
<span class="fc" id="L724">                new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
<span class="fc" id="L725">                break;</span>
            default:
<span class="nc" id="L727">                String message = &quot;invalid container type encountered during parsing &quot;</span>
                    + container
<span class="nc" id="L729">                    + _scanner.input_position();</span>
<span class="nc" id="L730">                throw new IonException(message);</span>
            }
        }
<span class="fc" id="L733">        return new_state;</span>
    }


    private final SymbolToken parseSymbolToken(String context,
                                                  StringBuilder sb,
                                                  int t)
        throws IOException
    {
        String text;
        int sid;

<span class="fc bfc" id="L745" title="All 2 branches covered.">        if (t == IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER) {</span>
<span class="fc" id="L746">            int kw = IonTokenConstsX.keyword(sb, 0, sb.length());</span>
<span class="fc bfc" id="L747" title="All 3 branches covered.">            switch (kw) {</span>
                case IonTokenConstsX.KEYWORD_FALSE:
                case IonTokenConstsX.KEYWORD_TRUE:
                case IonTokenConstsX.KEYWORD_NULL:
                case IonTokenConstsX.KEYWORD_NAN:
                    // keywords are not ok unless they're quoted
<span class="fc" id="L753">                    String reason =</span>
                    &quot;Cannot use unquoted keyword &quot; +
<span class="fc" id="L755">                        sb.toString() + &quot; as &quot; + context;</span>
<span class="nc" id="L756">                    parse_error(reason);</span>
                case IonTokenConstsX.KEYWORD_sid:
<span class="fc" id="L758">                    text = null;</span>
<span class="fc" id="L759">                    sid = IonTokenConstsX.decodeSid(sb);</span>
<span class="fc" id="L760">                    break;</span>
                default:
<span class="fc" id="L762">                    text = sb.toString();</span>
<span class="fc" id="L763">                    sid = UNKNOWN_SYMBOL_ID;</span>
                    break;
            }
<span class="fc" id="L766">        }</span>
        else {
<span class="fc" id="L768">            text = sb.toString();</span>
<span class="fc" id="L769">            sid = UNKNOWN_SYMBOL_ID;</span>
        }

<span class="fc" id="L772">        return new SymbolTokenImpl(text, sid);</span>
    }


    protected final void parse_to_next_value() throws IOException
    {
        int t;
        int action, temp_state;
<span class="fc" id="L780">        boolean trailing_whitespace = false;  // TODO: there's a better way to do this</span>
        StringBuilder sb;

        // FIXME: check depth and type before doing anything further
        //        if we're on a collection and at the correct depth
        //        we need to skip over the contents of the collection
        //        before doing any more parsing

        // we'll need a token to get started here
        // we'll also remember where we were when we started if the
        // user later wants to get a span over this value.  In the
        // case where we just before a comma, after the comma we'll
        // reset this offset since for the span the comma isn't part
        // of the span when it's hoisted
<span class="fc" id="L794">        _value_start_offset = _scanner.getStartingOffset();</span>
<span class="fc" id="L795">        _value_start_line   = _scanner.getLineNumber();</span>
<span class="fc" id="L796">        _value_start_column = _scanner.getLineOffset();</span>

<span class="fc" id="L798">        t = _scanner.nextToken();</span>

        for (;;) {
<span class="fc" id="L801">            int idx = get_state_int() * IonTokenConstsX.TOKEN_count + t;</span>
<span class="fc" id="L802">            action = TransitionActions2[idx];</span>
            // this used to be (but the 2d array is 9072ms vs 8786ms
            // timing, 3% of total file parse time!):
            // action = TransitionActions[get_state_int()][t];
<span class="pc bpc" id="L806" title="2 of 16 branches missed.">            switch (action) {</span>
            case ACTION_NOT_DEFINED:
                {
                    // TODO why would we get here?
<span class="fc" id="L810">                    boolean span_eof = false;</span>

<span class="pc bpc" id="L812" title="1 of 2 branches missed.">                    if (_nesting_parent != null) {</span>
<span class="nc bnc" id="L813" title="All 4 branches missed.">                        switch (_nesting_parent) {</span>
                            case LIST:
<span class="nc bnc" id="L815" title="All 2 branches missed.">                                if (t == IonTokenConstsX.TOKEN_CLOSE_SQUARE) {</span>
<span class="nc" id="L816">                                    span_eof = true;</span>
                                }
                                break;
                            case SEXP:
<span class="nc bnc" id="L820" title="All 2 branches missed.">                                if (t == IonTokenConstsX.TOKEN_CLOSE_PAREN){</span>
<span class="nc" id="L821">                                    span_eof = true;</span>
                                }
                                break;
                            case STRUCT:
<span class="nc bnc" id="L825" title="All 2 branches missed.">                                if (t == IonTokenConstsX.TOKEN_CLOSE_BRACE) {</span>
<span class="nc" id="L826">                                    span_eof = true;</span>
                                }
                                break;
                            default:
                                break;
                        }
                    }
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">                    if (span_eof != true) {</span>
<span class="fc" id="L834">                        String message = &quot;invalid syntax [state:&quot;</span>
<span class="fc" id="L835">                                       + get_state_name()</span>
                                       + &quot; on token:&quot;
<span class="fc" id="L837">                                       +IonTokenConstsX.getTokenName(t)</span>
                                       +&quot;]&quot;;
<span class="nc" id="L839">                        parse_error(message);</span>
                    }
<span class="nc" id="L841">                    set_state(STATE_EOF);</span>
<span class="nc" id="L842">                    _eof = true;</span>
<span class="nc" id="L843">                    return;</span>
                }
            case ACTION_EOF:
<span class="fc" id="L846">                set_state(STATE_EOF);</span>
<span class="fc" id="L847">                _eof = true;</span>
<span class="fc" id="L848">                return;</span>
            case ACTION_LOAD_FIELD_NAME:
            {
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">                if (!is_in_struct_internal()) {</span>
<span class="nc" id="L852">                    throw new IllegalStateException(&quot;field names have to be in structs&quot;);</span>
                }
                //finish_value(_current_value_save_point);
<span class="fc" id="L855">                finish_and_save_value();</span>

<span class="fc" id="L857">                sb = token_contents_load(t);</span>

<span class="fc" id="L859">                SymbolToken sym = parseSymbolToken(&quot;a field name&quot;, sb, t);</span>
<span class="fc" id="L860">                set_fieldname(sym);</span>
<span class="fc" id="L861">                clear_current_value_buffer();</span>

<span class="fc" id="L863">                t = _scanner.nextToken();</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">                if (t != IonTokenConstsX.TOKEN_COLON) {</span>
<span class="fc" id="L865">                    String message = &quot;field name must be followed by a colon, not a &quot;</span>
<span class="fc" id="L866">                                   + IonTokenConstsX.getTokenName(t);</span>
<span class="nc" id="L867">                    parse_error(message);</span>
                }
<span class="fc" id="L869">                _scanner.tokenIsFinished();</span>
<span class="fc" id="L870">                set_state(STATE_BEFORE_ANNOTATION_CONTAINED);</span>
<span class="fc" id="L871">                t = _scanner.nextToken();</span>
<span class="fc" id="L872">                break;</span>
            }
            case ACTION_LOAD_ANNOTATION:
            {
<span class="fc" id="L876">                sb = token_contents_load(t);</span>

<span class="fc" id="L878">                trailing_whitespace = _scanner.skip_whitespace();</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">                if (!_scanner.skipDoubleColon()) {</span>
                    // unnecessary: set_current_value(sp);
                    // this will &quot;loop around&quot; to ACTION_LOAD_SCALAR
                    // since this is necessarily a symbol of one
                    // sort of another
<span class="fc" id="L884">                    temp_state = get_state_after_annotation();</span>
<span class="fc" id="L885">                    set_state(temp_state);</span>
<span class="fc" id="L886">                    break;</span>
                }

                // We have an annotation!
<span class="fc" id="L890">                SymbolToken sym = parseSymbolToken(&quot;an annotation&quot;, sb, t);</span>
<span class="fc" id="L891">                append_annotation(sym);</span>
<span class="fc" id="L892">                clear_current_value_buffer();</span>

                // Consumed the annotation, move on.
                // note: that peekDoubleColon() consumed the two colons
                // so nextToken won't see them
<span class="fc" id="L897">                t = _scanner.nextToken();</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">                switch(t) {</span>
                case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
                case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
                    // This may be another annotation, so stay in this state
                    // and come around the horn again to check it out.
<span class="fc" id="L903">                    break;</span>
                default:
                    // we leave the error handling to the transition
<span class="fc" id="L906">                    temp_state = get_state_after_annotation();</span>
<span class="fc" id="L907">                    set_state(temp_state);</span>
<span class="fc" id="L908">                    break;</span>
                }
                break;
            }
            case ACTION_START_STRUCT:
<span class="fc" id="L913">                _value_type = IonType.STRUCT;</span>
<span class="fc" id="L914">                temp_state = STATE_BEFORE_FIELD_NAME;</span>
<span class="fc" id="L915">                set_state(temp_state);</span>
<span class="fc" id="L916">                return;</span>
            case ACTION_START_LIST:
<span class="fc" id="L918">                _value_type = IonType.LIST;</span>
<span class="fc" id="L919">                temp_state = STATE_BEFORE_ANNOTATION_CONTAINED;</span>
<span class="fc" id="L920">                set_state(temp_state);</span>
<span class="fc" id="L921">                return;</span>
            case ACTION_START_SEXP:
<span class="fc" id="L923">                _value_type = IonType.SEXP;</span>
<span class="fc" id="L924">                temp_state = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L925">                set_state(temp_state);</span>
<span class="fc" id="L926">                return;</span>
            case ACTION_START_LOB:
<span class="fc bfc" id="L928" title="All 3 branches covered.">                switch (_scanner.peekLobStartPunctuation()) {</span>
                case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="fc" id="L930">                    set_state(STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT);</span>
<span class="fc" id="L931">                    _lob_token = IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE;</span>
<span class="fc" id="L932">                    _value_type = IonType.CLOB;</span>
<span class="fc" id="L933">                    break;</span>
                case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="fc" id="L935">                    set_state(STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT);</span>
<span class="fc" id="L936">                    _lob_token = IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE;</span>
<span class="fc" id="L937">                    _value_type = IonType.CLOB;</span>
<span class="fc" id="L938">                    break;</span>
                default:
<span class="fc" id="L940">                    set_state(STATE_IN_BLOB_CONTENT);</span>
<span class="fc" id="L941">                    _lob_token = IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE;</span>
<span class="fc" id="L942">                    _value_type = IonType.BLOB;</span>
                    break;
                }
<span class="fc" id="L945">                return;</span>
            case ACTION_LOAD_SCALAR:
<span class="fc bfc" id="L947" title="All 2 branches covered.">                if (t == IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER) {</span>
<span class="fc" id="L948">                    sb = token_contents_load(t);</span>
<span class="fc" id="L949">                    _value_keyword = IonTokenConstsX.keyword(sb, 0, sb.length());</span>
<span class="fc bfc" id="L950" title="All 6 branches covered.">                    switch (_value_keyword) {</span>
                    case IonTokenConstsX.KEYWORD_NULL:
                    {
<span class="fc bfc" id="L953" title="All 2 branches covered.">                        int kwt = trailing_whitespace ? IonTokenConstsX.KEYWORD_none : _scanner.peekNullTypeSymbol();</span>
<span class="pc bpc" id="L954" title="1 of 15 branches missed.">                        switch (kwt) {</span>
<span class="fc" id="L955">                        case IonTokenConstsX.KEYWORD_NULL:      _null_type = IonType.NULL;       break;</span>
<span class="fc" id="L956">                        case IonTokenConstsX.KEYWORD_BOOL:      _null_type = IonType.BOOL;       break;</span>
<span class="fc" id="L957">                        case IonTokenConstsX.KEYWORD_INT:       _null_type = IonType.INT;        break;</span>
<span class="fc" id="L958">                        case IonTokenConstsX.KEYWORD_FLOAT:     _null_type = IonType.FLOAT;      break;</span>
<span class="fc" id="L959">                        case IonTokenConstsX.KEYWORD_DECIMAL:   _null_type = IonType.DECIMAL;    break;</span>
<span class="fc" id="L960">                        case IonTokenConstsX.KEYWORD_TIMESTAMP: _null_type = IonType.TIMESTAMP;  break;</span>
<span class="fc" id="L961">                        case IonTokenConstsX.KEYWORD_SYMBOL:    _null_type = IonType.SYMBOL;     break;</span>
<span class="fc" id="L962">                        case IonTokenConstsX.KEYWORD_STRING:    _null_type = IonType.STRING;     break;</span>
<span class="fc" id="L963">                        case IonTokenConstsX.KEYWORD_BLOB:      _null_type = IonType.BLOB;       break;</span>
<span class="fc" id="L964">                        case IonTokenConstsX.KEYWORD_CLOB:      _null_type = IonType.CLOB;       break;</span>
<span class="fc" id="L965">                        case IonTokenConstsX.KEYWORD_LIST:      _null_type = IonType.LIST;       break;</span>
<span class="fc" id="L966">                        case IonTokenConstsX.KEYWORD_SEXP:      _null_type = IonType.SEXP;       break;</span>
<span class="fc" id="L967">                        case IonTokenConstsX.KEYWORD_STRUCT:    _null_type = IonType.STRUCT;     break;</span>
<span class="fc" id="L968">                        case IonTokenConstsX.KEYWORD_none:      _null_type = IonType.NULL;       break; // this happens when there isn't a '.' otherwise peek throws the error or returns none</span>
<span class="nc" id="L969">                        default: parse_error(&quot;invalid keyword id (&quot;+kwt+&quot;) encountered while parsing a null&quot;);</span>
                        }
                        // at this point we've consumed a dot '.' and it's preceding whitespace
                        // clear_value();
<span class="fc" id="L973">                        current_value_is_null(_null_type);</span>
                        // set to null_type in above call: _value_type = IonType.NULL;
<span class="fc" id="L975">                        break;</span>
                    }
                    case IonTokenConstsX.KEYWORD_TRUE:
<span class="fc" id="L978">                        _value_type = IonType.BOOL;</span>
<span class="fc" id="L979">                        current_value_is_bool(true);</span>
<span class="fc" id="L980">                        break;</span>
                    case IonTokenConstsX.KEYWORD_FALSE:
<span class="fc" id="L982">                        _value_type = IonType.BOOL;</span>
<span class="fc" id="L983">                        current_value_is_bool(false);</span>
<span class="fc" id="L984">                        break;</span>
                    case IonTokenConstsX.KEYWORD_NAN:
<span class="fc" id="L986">                        _value_type = IonType.FLOAT;</span>
<span class="fc" id="L987">                        clear_current_value_buffer();</span>
<span class="fc" id="L988">                        _v.setValue(Double.NaN);</span>
<span class="fc" id="L989">                        _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L990">                        break;</span>
                    case IonTokenConstsX.KEYWORD_sid:
                    {
<span class="fc" id="L993">                        int sid = IonTokenConstsX.decodeSid(sb);</span>
<span class="fc" id="L994">                        _v.setValue(sid);</span>
<span class="fc" id="L995">                        _v.setAuthoritativeType(AS_TYPE.int_value);</span>
                    }
                    default:
                        // We don't care about any other 'keywords'
<span class="fc" id="L999">                        _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1000">                        break;</span>
                    }
                }
<span class="fc bfc" id="L1003" title="All 2 branches covered.">                else if (t == IonTokenConstsX.TOKEN_DOT) {</span>
<span class="fc" id="L1004">                    _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1005">                    clear_current_value_buffer();</span>
<span class="fc" id="L1006">                    _v.setValue(&quot;.&quot;);</span>
<span class="fc" id="L1007">                    _v.setAuthoritativeType(AS_TYPE.string_value);</span>
                }
                else {
                    // if it's not a symbol we just look at the token type
<span class="fc" id="L1011">                    _value_type = IonTokenConstsX.ion_type_of_scalar(t);</span>
                }
<span class="fc" id="L1013">                int state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1014">                set_state(state_after_scalar);</span>
<span class="fc" id="L1015">                return;</span>
            case ACTION_PLUS_INF:
<span class="fc" id="L1017">                _value_type = IonType.FLOAT;</span>
<span class="fc" id="L1018">                clear_current_value_buffer();</span>
<span class="fc" id="L1019">                _v.setValue(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L1020">                _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L1021">                state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1022">                set_state(state_after_scalar);</span>
<span class="fc" id="L1023">                return;</span>
            case ACTION_MINUS_INF:
<span class="fc" id="L1025">                _value_type = IonType.FLOAT;</span>
<span class="fc" id="L1026">                clear_current_value_buffer();</span>
<span class="fc" id="L1027">                _v.setValue(Double.NEGATIVE_INFINITY);</span>
<span class="fc" id="L1028">                _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L1029">                state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1030">                set_state(state_after_scalar);</span>
<span class="fc" id="L1031">                return;</span>
            case ACTION_EAT_COMMA:
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">                if (_container_prohibits_commas) {</span>
<span class="nc" id="L1034">                    parse_error(&quot;commas aren't used to separate values in &quot;+getContainerType().toString());</span>
                }
<span class="fc" id="L1036">                int new_state = STATE_BEFORE_ANNOTATION_CONTAINED;</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">                if (_container_is_struct) {</span>
<span class="fc" id="L1038">                    new_state = STATE_BEFORE_FIELD_NAME;</span>
                }
<span class="fc" id="L1040">                set_state(new_state);</span>
<span class="fc" id="L1041">                _scanner.tokenIsFinished();</span>
                // when we eat a comma we need to reset the current
                // value start used to define a span, since the comma
                // isn't part of the span when it's hoisted
<span class="fc" id="L1045">                _value_start_offset = _scanner.getStartingOffset();</span>
<span class="fc" id="L1046">                t = _scanner.nextToken();</span>
<span class="fc" id="L1047">                break;</span>
            case ACTION_FINISH_CONTAINER:
<span class="fc" id="L1049">                new_state = get_state_after_container(t);</span>
<span class="fc" id="L1050">                set_state(new_state);</span>
<span class="fc" id="L1051">                _eof = true;</span>
<span class="fc" id="L1052">                return;</span>
            case ACTION_FINISH_LOB:
<span class="nc" id="L1054">                state_after_scalar = get_state_after_value();</span>
<span class="nc" id="L1055">                set_state(state_after_scalar);</span>
<span class="nc" id="L1056">                return;</span>
            case ACTION_FINISH_DATAGRAM:
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">                if (getDepth() != 0) {</span>
<span class="nc" id="L1059">                    parse_error(&quot;state failure end of datagram encounterd with a non-container stack&quot;);</span>
                }
<span class="fc" id="L1061">                set_state(STATE_EOF);</span>
<span class="fc" id="L1062">                _eof = true;</span>
<span class="fc" id="L1063">                return;</span>
<span class="nc" id="L1064">            default: parse_error(&quot;unexpected token encountered: &quot;+IonTokenConstsX.getTokenName(t));</span>
            }
<span class="fc" id="L1066">        }</span>
    }

    protected final StringBuilder token_contents_load(int token_type) throws IOException
    {
<span class="fc" id="L1071">        StringBuilder sb = _current_value_buffer;</span>
        boolean       clob_chars_only;
        int           c;

<span class="fc bfc" id="L1075" title="All 2 branches covered.">        if (_current_value_buffer_loaded) {</span>
<span class="fc" id="L1076">            return sb;</span>
        }
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        else if (_current_value_save_point_loaded) {</span>
<span class="pc bpc" id="L1079" title="3 of 6 branches missed.">            assert(!_scanner.isUnfinishedToken() &amp;&amp; !_current_value_save_point.isClear());</span>
            // _scanner.load_save_point_contents( _current_value_save_point, sb);

<span class="fc" id="L1082">            _scanner.save_point_activate(_current_value_save_point);</span>
<span class="pc bpc" id="L1083" title="2 of 6 branches missed.">            switch (token_type) {</span>
            default:
<span class="nc" id="L1085">                _scanner.load_raw_characters(sb);</span>
<span class="nc" id="L1086">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
<span class="fc" id="L1088">                _scanner.load_symbol_identifier(sb);</span>
<span class="fc" id="L1089">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1090">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_OPERATOR:
<span class="nc" id="L1092">                _scanner.load_symbol_operator(sb);</span>
<span class="nc" id="L1093">                _value_type = IonType.SYMBOL;</span>
<span class="nc" id="L1094">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1097">                _scanner.load_single_quoted_string(sb, clob_chars_only);</span>
<span class="fc" id="L1098">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1099">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1102">                _scanner.load_double_quoted_string(sb, clob_chars_only);</span>
<span class="fc" id="L1103">                _value_type = IonType.STRING;</span>
<span class="fc" id="L1104">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1107">                _scanner.load_triple_quoted_string(sb, clob_chars_only);</span>
<span class="fc" id="L1108">                _value_type = IonType.STRING;</span>
                break;
            }
<span class="fc" id="L1111">            _scanner.save_point_deactivate(_current_value_save_point);</span>
<span class="fc" id="L1112">            _current_value_buffer_loaded = true;</span>
        }
        else {
<span class="fc" id="L1115">            _scanner.save_point_start(_current_value_save_point);</span>
<span class="pc bpc" id="L1116" title="1 of 7 branches missed.">            switch (token_type) {</span>
            case IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC:
            case IonTokenConstsX.TOKEN_INT:
            case IonTokenConstsX.TOKEN_BINARY:
            case IonTokenConstsX.TOKEN_HEX:
            case IonTokenConstsX.TOKEN_FLOAT:
            case IonTokenConstsX.TOKEN_DECIMAL:
            case IonTokenConstsX.TOKEN_TIMESTAMP:
<span class="fc" id="L1124">                _value_type = _scanner.load_number(sb);</span>
<span class="fc" id="L1125">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
<span class="fc" id="L1127">                _scanner.load_symbol_identifier(sb);</span>
<span class="fc" id="L1128">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1129">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_OPERATOR:
<span class="fc" id="L1131">                _scanner.load_symbol_operator(sb);</span>
<span class="fc" id="L1132">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1133">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1136">                c = _scanner.load_single_quoted_string(sb, clob_chars_only);</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">                if (c == UnifiedInputStreamX.EOF) {</span>
                    //String message = &quot;EOF encountered before closing single quote&quot;;
                    //parse_error(message);
<span class="nc" id="L1140">                    _scanner.unexpected_eof();</span>
                }
<span class="fc" id="L1142">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1143">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1146">                c = _scanner.load_double_quoted_string(sb, clob_chars_only);</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">                if (c == UnifiedInputStreamX.EOF) {</span>
                    // String message = &quot;EOF encountered before closing single quote&quot;;
                    // parse_error(message);
<span class="nc" id="L1150">                    _scanner.unexpected_eof();</span>
                }
<span class="fc" id="L1152">                _value_type = IonType.STRING;</span>
<span class="fc" id="L1153">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1156">                c = _scanner.load_triple_quoted_string(sb, clob_chars_only);</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">                if (c == UnifiedInputStreamX.EOF) {</span>
                    //String message = &quot;EOF encountered before closing single quote&quot;;
                    //parse_error(message);
<span class="nc" id="L1160">                    _scanner.unexpected_eof();</span>
                }
<span class="fc" id="L1162">                _value_type = IonType.STRING;</span>
<span class="fc" id="L1163">                break;</span>
            default:
<span class="nc" id="L1165">                String message = &quot;unexpected token &quot;</span>
<span class="nc" id="L1166">                               + IonTokenConstsX.getTokenName(token_type)</span>
                               + &quot; encountered&quot;;
<span class="nc" id="L1168">                throw new IonException(message);</span>
            }
<span class="fc" id="L1170">            _current_value_save_point.markEnd();</span>
<span class="fc" id="L1171">            _current_value_save_point_loaded = true;</span>
<span class="fc" id="L1172">            _current_value_buffer_loaded = true;</span>
<span class="fc" id="L1173">            tokenValueIsFinished();</span>
        }
<span class="fc" id="L1175">        return sb;</span>
    }

    /**
     * called by super classes to tell us that the
     * current token has been consumed.
     */
    protected void tokenValueIsFinished()
    {
<span class="fc" id="L1184">        _scanner.tokenIsFinished();</span>
<span class="fc bfc" id="L1185" title="All 4 branches covered.">        if (IonType.BLOB.equals(_value_type) || IonType.CLOB.equals(_value_type))</span>
        {
<span class="fc" id="L1187">            int state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1188">            set_state(state_after_scalar);</span>
        }
<span class="fc" id="L1190">    }</span>

    private final void push_container_state(IonType newContainer)
    {
<span class="fc" id="L1194">        int oldlen = _container_state_stack.length;</span>
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        if (_container_state_top &gt;= oldlen) {</span>
<span class="fc" id="L1196">            int newlen = oldlen * 2;</span>
<span class="fc" id="L1197">            IonType[] temp = new IonType[newlen];</span>
<span class="fc" id="L1198">            System.arraycopy(_container_state_stack, 0, temp, 0, oldlen);</span>
<span class="fc" id="L1199">            _container_state_stack = temp;</span>
        }
<span class="fc" id="L1201">        set_container_flags(newContainer);</span>
<span class="fc" id="L1202">        _container_state_stack[_container_state_top++] = newContainer;</span>
<span class="fc" id="L1203">    }</span>

    private final void pop_container_state() {
<span class="fc" id="L1206">        _container_state_top--;</span>
<span class="fc" id="L1207">        set_container_flags(top_state());</span>
<span class="fc" id="L1208">        _eof = false;</span>
<span class="fc" id="L1209">        _has_next_called = false;</span>

<span class="fc" id="L1211">        int new_state = get_state_after_container();</span>
<span class="fc" id="L1212">        set_state(new_state);</span>
<span class="fc" id="L1213">    }</span>

    private final IonType top_state() {
<span class="fc" id="L1216">        int top = _container_state_top - 1;</span>
<span class="fc" id="L1217">        IonType top_container = _container_state_stack[top];</span>
<span class="fc" id="L1218">        return top_container;</span>
    }

    public IonType getType()
    {
<span class="fc" id="L1223">        return _value_type;</span>
    }
    // externally we're if we're in a hoisted struct
    // we're not really in a struct, we at the top level
    public boolean isInStruct()
    {
<span class="fc" id="L1229">        boolean in_struct = false;</span>
<span class="fc" id="L1230">        IonType container = getContainerType();</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        if (IonType.STRUCT.equals(container)) {</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">            if (getDepth() &gt; 0) {</span>
<span class="fc" id="L1233">                in_struct = true;</span>
            }
            else {
<span class="pc bpc" id="L1236" title="2 of 4 branches missed.">                assert(IonType.STRUCT.equals(_nesting_parent) == true);</span>
            }
        }
<span class="fc" id="L1239">        return in_struct;</span>
    }
    // internally (really only in parse_to_next()) we care
    // about being in a struct even if it's a hoisted container
    // since the hoisted values will still have a field name we
    // have to ignore
    private boolean is_in_struct_internal()
    {
<span class="fc" id="L1247">        boolean in_struct = false;</span>
<span class="fc" id="L1248">        IonType container = getContainerType();</span>
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        if (IonType.STRUCT.equals(container)) {</span>
<span class="fc" id="L1250">            in_struct = true;</span>
        }
<span class="fc" id="L1252">        return in_struct;</span>
    }
    public IonType getContainerType()
    {
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">        if (_container_state_top == 0) return IonType.DATAGRAM;</span>
<span class="fc" id="L1257">        return _container_state_stack[_container_state_top - 1];</span>
    }
    public int getDepth()
    {
<span class="fc" id="L1261">        int depth = _container_state_top;</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">        if (depth &gt; 0) {</span>
<span class="fc" id="L1263">int debugging_depth = depth;</span>
<span class="fc" id="L1264">            IonType top_type = _container_state_stack[0];</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">            if (_nesting_parent == null) {</span>
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">                if (IonType.DATAGRAM.equals(top_type)) {</span>
<span class="fc" id="L1267">                    depth--;</span>
                }
            }
            else {
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">                if (_nesting_parent.equals(top_type)) {</span>
<span class="fc" id="L1272">                    depth--;</span>
                }
            }
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">if (depth == debugging_depth) {</span>
<span class="nc" id="L1276">    System.err.println(&quot;so here's a case where we didn't subtract 1&quot;);</span>
}
        }
<span class="fc" id="L1279">        return depth;</span>
    }

    public String getFieldName()
    {
        // For hoisting
<span class="nc bnc" id="L1285" title="All 4 branches missed.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return null;</span>

<span class="nc" id="L1287">        String name = _field_name;</span>
<span class="nc bnc" id="L1288" title="All 4 branches missed.">        if (name == null &amp;&amp; _field_name_sid &gt; 0)</span>
        {
<span class="nc" id="L1290">            throw new UnknownSymbolException(_field_name_sid);</span>
        }
<span class="nc" id="L1292">        return name;</span>
    }

    final String getRawFieldName()
    {
        // For hoisting
<span class="fc bfc" id="L1298" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return null;</span>
<span class="fc" id="L1299">        return _field_name;</span>
    }

    public int getFieldId()
    {
        // For hoisting
<span class="fc bfc" id="L1305" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L1306">        return _field_name_sid;</span>
    }

    public SymbolToken getFieldNameSymbol()
    {
        // For hoisting
<span class="fc bfc" id="L1312" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return null;</span>

<span class="fc" id="L1314">        String name = _field_name;</span>
<span class="fc" id="L1315">        int sid = getFieldId();</span>
<span class="fc bfc" id="L1316" title="All 4 branches covered.">        if (name == null &amp;&amp; sid == UNKNOWN_SYMBOL_ID) return null;</span>
<span class="fc" id="L1317">        return new SymbolTokenImpl(name, sid);</span>
    }

    public Iterator&lt;String&gt; iterateTypeAnnotations()
    {
<span class="fc" id="L1322">        return _Private_Utils.stringIterator(getTypeAnnotations());</span>
    }

    public void stepIn()
    {
<span class="pc bpc" id="L1327" title="2 of 4 branches missed.">        if (_value_type == null || _eof) {</span>
<span class="nc" id="L1328">            throw new IllegalStateException();</span>
        }
<span class="pc bpc" id="L1330" title="1 of 2 branches missed.">        switch (_value_type) {</span>
        case STRUCT:
        case LIST:
        case SEXP:
<span class="fc" id="L1334">            break;</span>
        default:
<span class="nc" id="L1336">            throw new IllegalStateException(&quot;Unexpected value type: &quot; + _value_type);</span>
        }

<span class="fc" id="L1339">        int new_state = get_state_at_container_start(_value_type);</span>
<span class="fc" id="L1340">        set_state(new_state);</span>

<span class="fc" id="L1342">        push_container_state(_value_type);</span>

<span class="fc" id="L1344">        _scanner.tokenIsFinished();</span>
        try {
<span class="fc" id="L1346">            finish_value(null);</span>
        }
<span class="nc" id="L1348">        catch (IOException e) {</span>
<span class="nc" id="L1349">            throw new IonException(e);</span>
<span class="fc" id="L1350">        }</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">        if (_v.isNull()) {</span>
<span class="fc" id="L1352">            _eof = true;</span>
<span class="fc" id="L1353">            _has_next_called = true;  // there are no contents in a null container</span>
        }

<span class="fc" id="L1356">        _value_type = null;</span>

        if (_debug) System.out.println(&quot;stepInto() new depth: &quot;+getDepth());
<span class="fc" id="L1359">    }</span>
    public void stepOut()
    {
<span class="fc bfc" id="L1362" title="All 2 branches covered.">        if (getDepth() &lt; 1) {</span>
<span class="fc" id="L1363">            throw new IllegalStateException(IonMessages.CANNOT_STEP_OUT);</span>
        }
        try {
<span class="fc" id="L1366">            finish_value(null);</span>
<span class="pc bpc" id="L1367" title="2 of 5 branches missed.">            switch (getContainerType()) {</span>
            case STRUCT:
<span class="fc bfc" id="L1369" title="All 2 branches covered.">                if (!_eof) _scanner.skip_over_struct();</span>
                break;
            case LIST:
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                if (!_eof) _scanner.skip_over_list();</span>
                break;
            case SEXP:
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                if (!_eof) _scanner.skip_over_sexp();</span>
                break;
            case DATAGRAM:
<span class="nc" id="L1378">                break;</span>
            default:
<span class="nc" id="L1380">                throw new IllegalStateException(&quot;Unexpected value type: &quot; + _value_type);</span>
            }
        }
<span class="nc" id="L1383">        catch (IOException e) {</span>
<span class="nc" id="L1384">            throw new IonException(e);</span>
<span class="fc" id="L1385">        }</span>
<span class="fc" id="L1386">        pop_container_state();</span>
<span class="fc" id="L1387">        _scanner.tokenIsFinished();</span>
        try {
<span class="fc" id="L1389">            finish_value(null);</span>
        }
<span class="nc" id="L1391">        catch (IOException e) {</span>
<span class="nc" id="L1392">            throw new IonException(e);</span>
<span class="fc" id="L1393">        }</span>

<span class="fc" id="L1395">        clear_value();</span>

        if (_debug) System.out.println(&quot;stepOUT() new depth: &quot;+getDepth());
<span class="fc" id="L1398">    }</span>

    //
    // symbol related code that is inactive in this parser
    //
    public SymbolTable getSymbolTable()
    {
<span class="fc" id="L1405">        return null;</span>
    }

    //
    // helper classes
    //

    public static class IonReaderTextParsingException extends IonException {
        private static final long serialVersionUID = 1L;

        IonReaderTextParsingException(String msg) {
<span class="fc" id="L1416">            super(msg);</span>
<span class="fc" id="L1417">        }</span>
        IonReaderTextParsingException(Exception e) {
<span class="nc" id="L1419">            super(e);</span>
<span class="nc" id="L1420">        }</span>
        IonReaderTextParsingException(String msg, Exception e) {
<span class="fc" id="L1422">            super(msg, e);</span>
<span class="fc" id="L1423">        }</span>
    }

    protected final void parse_error(String reason) {
<span class="fc" id="L1427">        String message =</span>
                &quot;Syntax error&quot;
<span class="fc" id="L1429">              + _scanner.input_position()</span>
              + &quot;: &quot;
              + reason;
<span class="fc" id="L1432">        throw new IonReaderTextParsingException(message);</span>
    }
    protected final void parse_error(Exception e) {
<span class="fc" id="L1435">        String message =</span>
                &quot;Syntax error at &quot;
<span class="fc" id="L1437">              + _scanner.input_position()</span>
              + &quot;: &quot;
<span class="fc" id="L1439">              + e.getLocalizedMessage();</span>
<span class="fc" id="L1440">        throw new IonReaderTextParsingException(message, e);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>