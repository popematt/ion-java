<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonTokenConstsX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonTokenConstsX.java</span></div><h1>IonTokenConstsX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import com.amazon.ion.IonException;
import com.amazon.ion.IonType;
import com.amazon.ion.impl._Private_ScalarConversions.CantConvertException;


/**
 * this is a collection of constants and some static helper functions
 * to support tokenizing Ion text
 */
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">final class IonTokenConstsX</span>
{
<span class="nc" id="L29">    public static class CharacterSequence {</span>
        public static final int CHAR_SEQ_EOF                         = -1; // matches -1 (stream eof)
        public static final int CHAR_SEQ_STRING_TERMINATOR           = -2; // can't be &gt;=0, ==-1 (eof), nor -2 (empty esc)
        public static final int CHAR_SEQ_STRING_NON_TERMINATOR       = -3; // used for a pair of triple quotes treated a nothing

        public static final int CHAR_SEQ_NEWLINE_SEQUENCE_1          = -4;  // single new line
        public static final int CHAR_SEQ_NEWLINE_SEQUENCE_2          = -5;  // single carriage return
        public static final int CHAR_SEQ_NEWLINE_SEQUENCE_3          = -6;  // new line - carriage return pair
        public static final int CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1  = -7;  // escape followed by new line
        public static final int CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2  = -8;  // escape followed by carriage return
        public static final int CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3  = -9;  // escape followed by new line - carriage return pair
    }

    public static final int TOKEN_ERROR                 = -1;
    public static final int TOKEN_EOF                   =  0;

    public static final int TOKEN_UNKNOWN_NUMERIC       =  1;
    public static final int TOKEN_INT                   =  2;
    public static final int TOKEN_HEX                   =  3;
    public static final int TOKEN_DECIMAL               =  4;
    public static final int TOKEN_FLOAT                 =  5;
    public static final int TOKEN_FLOAT_INF             =  6;
    public static final int TOKEN_FLOAT_MINUS_INF       =  7;
    public static final int TOKEN_TIMESTAMP             =  8;

    /**
     * Unquoted identifier symbol, including keywords like {@code true} and
     * {@code nan} as well as SIDs like {@code $123}
     */
    public static final int TOKEN_SYMBOL_IDENTIFIER     =  9;
    /** Single-quoted symbol */
    public static final int TOKEN_SYMBOL_QUOTED         = 10;
    /** Unquoted operator sequence for sexp */
    public static final int TOKEN_SYMBOL_OPERATOR       = 11;

    public static final int TOKEN_STRING_DOUBLE_QUOTE   = 12;
    public static final int TOKEN_STRING_TRIPLE_QUOTE   = 13;

    public static final int TOKEN_DOT                   = 14;
    public static final int TOKEN_COMMA                 = 15;
    public static final int TOKEN_COLON                 = 16;
    public static final int TOKEN_DOUBLE_COLON          = 17;

    public static final int TOKEN_OPEN_PAREN            = 18;
    public static final int TOKEN_CLOSE_PAREN           = 19;
    public static final int TOKEN_OPEN_BRACE            = 20;
    public static final int TOKEN_CLOSE_BRACE           = 21;
    public static final int TOKEN_OPEN_SQUARE           = 22;
    public static final int TOKEN_CLOSE_SQUARE          = 23;

    public static final int TOKEN_OPEN_DOUBLE_BRACE     = 24;
    public static final int TOKEN_CLOSE_DOUBLE_BRACE    = 25;

    public static final int TOKEN_BINARY                = 26;

    public static final int TOKEN_MAX                   = 26;
    public static final int TOKEN_count                 = 27;

    public static final int KEYWORD_unrecognized = -1;
    public static final int KEYWORD_none         =  0;
    public static final int KEYWORD_TRUE      =  1;
    public static final int KEYWORD_FALSE     =  2;
    public static final int KEYWORD_NULL      =  3;
    public static final int KEYWORD_BOOL      =  4;
    public static final int KEYWORD_INT       =  5;
    public static final int KEYWORD_FLOAT     =  6;
    public static final int KEYWORD_DECIMAL   =  7;
    public static final int KEYWORD_TIMESTAMP =  8;
    public static final int KEYWORD_SYMBOL    =  9;
    public static final int KEYWORD_STRING    = 10;
    public static final int KEYWORD_BLOB      = 11;
    public static final int KEYWORD_CLOB      = 12;
    public static final int KEYWORD_LIST      = 13;
    public static final int KEYWORD_SEXP      = 14;
    public static final int KEYWORD_STRUCT    = 15;
    public static final int KEYWORD_NAN       = 16;
    public static final int KEYWORD_sid       = 17;

    public final static String getTokenName(int t) {
<span class="pc bpc" id="L108" title="17 of 28 branches missed.">        switch (t) {</span>
<span class="nc" id="L109">        case TOKEN_ERROR:              return &quot;TOKEN_ERROR&quot;;</span>
<span class="fc" id="L110">        case TOKEN_EOF:                return &quot;TOKEN_EOF&quot;;</span>

<span class="fc" id="L112">        case TOKEN_UNKNOWN_NUMERIC:    return &quot;TOKEN_UNKNOWN_NUMERIC&quot;;</span>
<span class="nc" id="L113">        case TOKEN_INT:                return &quot;TOKEN_INT&quot;;</span>
<span class="nc" id="L114">        case TOKEN_HEX:                return &quot;TOKEN_HEX&quot;;</span>
<span class="nc" id="L115">        case TOKEN_DECIMAL:            return &quot;TOKEN_DECIMAL&quot;;</span>
<span class="nc" id="L116">        case TOKEN_FLOAT:              return &quot;TOKEN_FLOAT&quot;;</span>
<span class="nc" id="L117">        case TOKEN_FLOAT_INF:          return &quot;TOKEN_FLOAT_INF&quot;;</span>
<span class="nc" id="L118">        case TOKEN_FLOAT_MINUS_INF:    return &quot;TOKEN_FLOAT_MINUS_INF&quot;;</span>
<span class="nc" id="L119">        case TOKEN_TIMESTAMP:          return &quot;TOKEN_TIMESTAMP&quot;;</span>

<span class="fc" id="L121">        case TOKEN_SYMBOL_IDENTIFIER:  return &quot;TOKEN_SYMBOL_IDENTIFIER&quot;;</span>
<span class="nc" id="L122">        case TOKEN_SYMBOL_QUOTED:      return &quot;TOKEN_SYMBOL_QUOTED&quot;;</span>
<span class="fc" id="L123">        case TOKEN_SYMBOL_OPERATOR:    return &quot;TOKEN_SYMBOL_OPERATOR&quot;;</span>
<span class="nc" id="L124">        case TOKEN_STRING_DOUBLE_QUOTE:return &quot;TOKEN_STRING_DOUBLE_QUOTE&quot;;</span>
<span class="nc" id="L125">        case TOKEN_STRING_TRIPLE_QUOTE:return &quot;TOKEN_STRING_TRIPLE_QUOTE&quot;;</span>

<span class="fc" id="L127">        case TOKEN_DOT:                return &quot;TOKEN_DOT&quot;;</span>
<span class="fc" id="L128">        case TOKEN_COMMA:              return &quot;TOKEN_COMMA&quot;;</span>
<span class="fc" id="L129">        case TOKEN_COLON:              return &quot;TOKEN_COLON&quot;;</span>
<span class="fc" id="L130">        case TOKEN_DOUBLE_COLON:       return &quot;TOKEN_DOUBLE_COLON&quot;;</span>

<span class="fc" id="L132">        case TOKEN_OPEN_PAREN:         return &quot;TOKEN_OPEN_PAREN&quot;;</span>
<span class="nc" id="L133">        case TOKEN_CLOSE_PAREN:        return &quot;TOKEN_CLOSE_PAREN&quot;;</span>
<span class="nc" id="L134">        case TOKEN_OPEN_BRACE:         return &quot;TOKEN_OPEN_BRACE&quot;;</span>
<span class="fc" id="L135">        case TOKEN_CLOSE_BRACE:        return &quot;TOKEN_CLOSE_BRACE&quot;;</span>
<span class="fc" id="L136">        case TOKEN_OPEN_SQUARE:        return &quot;TOKEN_OPEN_SQUARE&quot;;</span>
<span class="nc" id="L137">        case TOKEN_CLOSE_SQUARE:       return &quot;TOKEN_CLOSE_SQUARE&quot;;</span>

<span class="nc" id="L139">        case TOKEN_OPEN_DOUBLE_BRACE:  return &quot;TOKEN_OPEN_DOUBLE_BRACE&quot;;</span>
<span class="nc" id="L140">        case TOKEN_CLOSE_DOUBLE_BRACE: return &quot;TOKEN_CLOSE_DOUBLE_BRACE&quot;;</span>

<span class="nc" id="L142">        default: return &quot;&lt;invalid token &quot;+t+&quot;&gt;&quot;;</span>
        }
    }
    public final static String describeToken(int t) {
<span class="pc bpc" id="L146" title="6 of 9 branches missed.">        switch (t) {</span>
<span class="nc" id="L147">        case TOKEN_OPEN_PAREN:         return &quot;(&quot;;</span>
<span class="fc" id="L148">        case TOKEN_CLOSE_PAREN:        return &quot;)&quot;;</span>
<span class="nc" id="L149">        case TOKEN_OPEN_BRACE:         return &quot;{&quot;;</span>
<span class="fc" id="L150">        case TOKEN_CLOSE_BRACE:        return &quot;}&quot;;</span>
<span class="nc" id="L151">        case TOKEN_OPEN_SQUARE:        return &quot;[&quot;;</span>
<span class="fc" id="L152">        case TOKEN_CLOSE_SQUARE:       return &quot;]&quot;;</span>

<span class="nc" id="L154">        case TOKEN_OPEN_DOUBLE_BRACE:  return &quot;{{&quot;;</span>
<span class="nc" id="L155">        case TOKEN_CLOSE_DOUBLE_BRACE: return &quot;}}&quot;;</span>

<span class="nc" id="L157">        default: return getTokenName(t);</span>
        }
    }
    public static final IonType ion_type_of_scalar(int token) {
<span class="pc bpc" id="L161" title="1 of 12 branches missed.">        switch(token) {</span>
<span class="fc" id="L162">        case TOKEN_INT:                 return IonType.INT;</span>
<span class="fc" id="L163">        case TOKEN_BINARY:              return IonType.INT;</span>
<span class="fc" id="L164">        case TOKEN_HEX:                 return IonType.INT;</span>
<span class="fc" id="L165">        case TOKEN_DECIMAL:             return IonType.DECIMAL;</span>
<span class="fc" id="L166">        case TOKEN_FLOAT:               return IonType.FLOAT;</span>
<span class="fc" id="L167">        case TOKEN_TIMESTAMP:           return IonType.TIMESTAMP;</span>
<span class="nc" id="L168">        case TOKEN_SYMBOL_IDENTIFIER:   return IonType.SYMBOL;</span>
<span class="fc" id="L169">        case TOKEN_SYMBOL_QUOTED:       return IonType.SYMBOL;</span>
<span class="fc" id="L170">        case TOKEN_SYMBOL_OPERATOR:     return IonType.SYMBOL;</span>
<span class="fc" id="L171">        case TOKEN_STRING_DOUBLE_QUOTE: return IonType.STRING;</span>
<span class="fc" id="L172">        case TOKEN_STRING_TRIPLE_QUOTE: return IonType.STRING;</span>
<span class="fc" id="L173">        default:                        return null;</span>
        }
    }

<span class="fc" id="L177">    public static final char[] BLOB_TERMINATOR               = new char[]  { '}', '}' };</span>
<span class="fc" id="L178">    public static final char[] CLOB_DOUBLE_QUOTED_TERMINATOR = new char[]  { '\'', '\'', '\'' };</span>
<span class="fc" id="L179">    public static final char[] CLOB_TRIPLE_QUOTED_TERMINATOR = new char[]  { '&quot;' };</span>

    public static final boolean is8bitValue(int v) {
<span class="fc bfc" id="L182" title="All 2 branches covered.">        return (v &amp; ~0xff) == 0;</span>
    }
    public static final boolean is7bitValue(int v) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">        return (v &amp; ~0x7f) == 0;</span>
    }
    public static final boolean isWhitespace(int c) {
<span class="pc bpc" id="L188" title="3 of 8 branches missed.">        return (c == ' ' || c == '\t' || c == '\n' || c == '\r');</span>
    }

<span class="fc" id="L191">    public final static boolean[] isBase64Character = makeBase64Array();</span>
    public final static int       base64FillerCharacter = '=';
    private static boolean[] makeBase64Array()
    {
<span class="fc" id="L195">        boolean[] base64 = new boolean[256];</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L198">            base64[ii] = true;</span>
        }
<span class="fc bfc" id="L200" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L201">            base64[ii] = true;</span>
        }
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L204">            base64[ii] = true;</span>
        }
<span class="fc" id="L206">        base64['+'] = true;</span>
<span class="fc" id="L207">        base64['/'] = true;</span>
<span class="fc" id="L208">        return base64;</span>
    }

<span class="fc" id="L211">    public final static int[] hexValue = makeHexValueArray();</span>
<span class="fc" id="L212">    public final static boolean[] isHexDigit = makeHexDigitTestArray(hexValue);</span>
    private final static int[] makeHexValueArray() {
<span class="fc" id="L214">        int[] hex = new int[256];</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int ii=0; ii&lt;256; ii++) {</span>
<span class="fc" id="L216">            hex[ii] = -1;</span>
        }
<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L219">            hex[ii] = ii - '0';</span>
        }
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='f'; ii++) {</span>
<span class="fc" id="L222">            hex[ii] = ii - 'a' + 10;</span>
        }
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='F'; ii++) {</span>
<span class="fc" id="L225">            hex[ii] = ii - 'A' + 10;</span>
        }
<span class="fc" id="L227">        return hex;</span>
    }
    private final static boolean[] makeHexDigitTestArray(int [] hex_characters) {
<span class="fc" id="L230">        boolean[] is_hex = new boolean[hex_characters.length];</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (int ii=0; ii&lt;hex_characters.length; ii++) {</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            is_hex[ii] = (hex_characters[ii] &gt;= 0);</span>
        }
<span class="fc" id="L234">        return is_hex;</span>
    }

    public static final boolean isBinaryDigit(int c) {
<span class="fc bfc" id="L238" title="All 4 branches covered.">        return c =='0' || c == '1';</span>
    }

    public final static boolean isHexDigit(int c) {
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">        return isHexDigit[c &amp; 0xff] &amp;&amp; is8bitValue(c);</span>
    }

    public final static int hexDigitValue(int c) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (!isHexDigit(c)) {</span>
<span class="fc" id="L247">            IllegalArgumentException e = new IllegalArgumentException(&quot;character '&quot;+((char)c)+&quot;' is not a hex digit&quot;);</span>
<span class="fc" id="L248">            throw new IonException(e);</span>
        }
<span class="fc" id="L250">        return hexValue[c];</span>
    }
/*
    public final static int[] decimalValue = makeDecimalValueArray();
    public final static boolean[] isDecimalDigit = makeDecimalDigitTestArray(decimalValue);
    private final static int[] makeDecimalValueArray() {
        int[] dec = new int[256];
        for (int ii=0; ii&lt;256; ii++) {
            dec[ii] = -1;
        }
        for (int ii='0'; ii&lt;='9'; ii++) {
            dec[ii] = ii - '0';
        }
        return dec;
    }
    private final static boolean[] makeDecimalDigitTestArray(int [] dec_characters) {
        boolean[] is_hex = new boolean[dec_characters.length];
        for (int ii=0; ii&lt;dec_characters.length; ii++) {
            is_hex[ii] = (dec_characters[ii] &gt;= 0);
        }
        return is_hex;
    }
*/
    public final static boolean isDigit(int c) {
<span class="fc bfc" id="L274" title="All 4 branches covered.">        return (c &gt;= '0' &amp;&amp; c &lt;= '9');</span>
    }
    public final static int decimalDigitValue(int c) {
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (!isDigit(c)) {</span>
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;character '&quot;+((char)c)+&quot;' is not a hex digit&quot;);</span>
        }
<span class="nc" id="L280">        return c - '0'; // decimalValue[c];</span>
    }

    public static final int CLOB_CHARACTER_LIMIT = 0xFF;
    public static final int ESCAPE_LITTLE_U_MINIMUM = 0x100;
    public static final int ESCAPE_BIG_U_MINIMUM = 0x10000;

    public static final int ESCAPE_HEX = -16;
    public static final int ESCAPE_BIG_U = -15;
    public static final int ESCAPE_LITTLE_U = -14;
    public static final int ESCAPE_REMOVES_NEWLINE2 = -13;
    public static final int ESCAPE_REMOVES_NEWLINE = -12;
    public static final int ESCAPE_NOT_DEFINED = -11;

<span class="fc" id="L294">    private static final int escapeCharactersValues[] = makeEscapeCharacterValuesArray();</span>
    private static final int[] makeEscapeCharacterValuesArray() {
<span class="fc" id="L296">        int[] values = new int[256];</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        for (int ii=0; ii&lt;256; ii++) {</span>
<span class="fc" id="L298">            values[ii] = ESCAPE_NOT_DEFINED;</span>
        }
<span class="fc" id="L300">        values['0'] = 0;        //    \u0000  \0  alert NUL</span>
<span class="fc" id="L301">        values['a'] = 7;        //    \u0007  \a  alert BEL</span>
<span class="fc" id="L302">        values['b'] = 8;        //    \u0008  \b  backspace BS</span>
<span class="fc" id="L303">        values['t'] = 9;        //    \u0009  \t  horizontal tab HT</span>
<span class="fc" id="L304">        values['n'] = '\n';     //    \ u000A  \ n  linefeed LF</span>
<span class="fc" id="L305">        values['f'] = 0x0c;     //    \u000C  \f  form feed FF</span>
<span class="fc" id="L306">        values['r'] = '\r';     //    \ u000D  \ r  carriage return CR</span>
<span class="fc" id="L307">        values['v'] = 0x0b;     //    \u000B  \v  vertical tab VT</span>
<span class="fc" id="L308">        values['&quot;'] = '&quot;';      //    \u0022  \&quot;  double quote</span>
<span class="fc" id="L309">        values['\''] = '\'';    //    \u0027  \'  single quote</span>
<span class="fc" id="L310">        values['?'] = '?';      //    \u003F  \?  question mark</span>
<span class="fc" id="L311">        values['\\'] = '\\';    //    \u005C  \\  backslash</span>
<span class="fc" id="L312">        values['/'] = '/';      //    \u002F  \/  forward slash nothing  \NL  escaped NL expands to nothing</span>
<span class="fc" id="L313">        values['\n'] = ESCAPE_REMOVES_NEWLINE;  // slash-new line the new line eater</span>
<span class="fc" id="L314">        values['\r'] = ESCAPE_REMOVES_NEWLINE2;  // slash-new line the new line eater</span>
<span class="fc" id="L315">        values['x'] = ESCAPE_HEX; //    any  \xHH  2-digit hexadecimal unicode character equivalent to \ u00HH</span>
<span class="fc" id="L316">        values['u'] = ESCAPE_LITTLE_U; //    any  \ uHHHH  4-digit hexadecimal unicode character</span>
<span class="fc" id="L317">        values['U'] = ESCAPE_BIG_U;</span>
<span class="fc" id="L318">        return values;</span>
    }
<span class="fc" id="L320">    private static final String escapeCharacterImage[] = makeEscapeCharacterImageArray();</span>
    public final static String [] makeEscapeCharacterImageArray() {
<span class="fc" id="L322">        String [] values = new String[256];</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">        for (int ii=0; ii&lt;256; ii++) {</span>
<span class="fc" id="L325">            values[ii] = null;</span>
        }

<span class="fc" id="L328">        values['0'] = &quot;\\0&quot;;        //    \u0000  \0  alert NUL</span>
<span class="fc" id="L329">        values['a'] = &quot;\\a&quot;;        //    \u0007  \a  alert BEL</span>
<span class="fc" id="L330">        values['b'] = &quot;\\b&quot;;        //    \u0008  \b  backspace BS</span>
<span class="fc" id="L331">        values['t'] = &quot;\\t&quot;;        //    \u0009  \t  horizontal tab HT</span>
<span class="fc" id="L332">        values['n'] = &quot;\\n&quot;;        //    \ u000A \n line feed LF</span>
<span class="fc" id="L333">        values['f'] = &quot;\\f&quot;;        //    \u000C  \f  form feed FF</span>
<span class="fc" id="L334">        values['r'] = &quot;\\r&quot;;        //    \ u000D \r  carriage return CR</span>
<span class="fc" id="L335">        values['v'] = &quot;\\v&quot;;        //    \u000B  \v  vertical tab VT</span>
<span class="fc" id="L336">        values['&quot;'] = &quot;\\\&quot;&quot;;       //    \u0022  \&quot;  double quote</span>
<span class="fc" id="L337">        values['\''] = &quot;\\&quot;+&quot;'&quot;;    //    \u0027  \'  single quote</span>
<span class="fc" id="L338">        values['?'] = &quot;\\?&quot;;        //    \u003F  \?  question mark</span>
<span class="fc" id="L339">        values['\\'] = &quot;\\&quot;+&quot;\\&quot;;   //    \u005C  \\  backslash</span>
<span class="fc" id="L340">        values['/'] = &quot;\\/&quot;;        //    \u002F  \/  forward slash nothing  \NL  escaped NL expands to nothing</span>

<span class="fc" id="L342">        return values;</span>
    }
    public final static String getEscapeCharacterImage(int c) {
<span class="nc bnc" id="L345" title="All 4 branches missed.">        if (c &lt; 0 || c &gt; 255) {</span>
<span class="nc" id="L346">            throw new IllegalArgumentException(&quot;character is outside escapable range (0-255 inclusive)&quot;);</span>
        }
<span class="nc" id="L348">        return escapeCharacterImage[c];</span>
    }

    public final static boolean isValidEscapeStart(int c) {
<span class="fc bfc" id="L352" title="All 2 branches covered.">        return (escapeCharactersValues[c &amp; 0xff] != ESCAPE_NOT_DEFINED)</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">         &amp;&amp; is8bitValue(c);</span>
    }
    public final static int escapeReplacementCharacter(int c) {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (!isValidEscapeStart(c)) {</span>
<span class="nc" id="L357">            throw new IllegalArgumentException(&quot;not a valid escape sequence character: &quot;+c);</span>
        }
<span class="fc" id="L359">        return escapeCharactersValues[c];</span>
    }

    // escapeType
<span class="nc" id="L363">    public enum EscapeType {</span>
<span class="nc" id="L364">                    ESCAPE_DESTINATION_NONE,</span>
<span class="nc" id="L365">                    ESCAPE_DESTINATION_STRING,</span>
<span class="nc" id="L366">                    ESCAPE_DESTINATION_SYMBOL,</span>
<span class="nc" id="L367">                    ESCAPE_DESTINATION_CLOB</span>
    }
    public final static boolean needsIonEscape(EscapeType escapeType, int c) {
<span class="nc bnc" id="L370" title="All 5 branches missed.">        switch(escapeType) {</span>
<span class="nc" id="L371">        case ESCAPE_DESTINATION_NONE:   return false;</span>
<span class="nc" id="L372">        case ESCAPE_DESTINATION_STRING: return needsStringEscape(c);</span>
<span class="nc" id="L373">        case ESCAPE_DESTINATION_SYMBOL: return needsSymbolEscape(c);</span>
<span class="nc" id="L374">        case ESCAPE_DESTINATION_CLOB:   return needsClobEscape(c);</span>
<span class="nc" id="L375">        default:                        throw new IllegalArgumentException(&quot;escapeType &quot;+escapeType+&quot; is unrecognized&quot;);</span>
        }
    }
    public final static boolean needsSymbolEscape(int c) {
<span class="nc bnc" id="L379" title="All 6 branches missed.">        return (c &lt; 32 || c == '\'' || c == '\\');</span>
    }
    public final static boolean needsStringEscape(int c) {
<span class="nc bnc" id="L382" title="All 6 branches missed.">        return (c &lt; 32 || c == '&quot;' || c == '\\');</span>
    }
    public final static boolean needsClobEscape(int c) {
<span class="nc bnc" id="L385" title="All 8 branches missed.">        return (c &lt; 32 || c == '&quot;' || c == '\\' || c &gt; 127);</span>
    }
    public static String escapeSequence(int c) {
<span class="nc bnc" id="L388" title="All 4 branches missed.">        if (c &gt;= 0 || c &lt;= 0x10FFFF) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (c &lt; 128) {</span>
<span class="nc" id="L390">                return escapeCharacterImage[c];</span>
            }
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (c &lt; 0xFFFF) {</span>
<span class="nc" id="L393">                String short_hex = Integer.toHexString(c);</span>
<span class="nc" id="L394">                int    short_len = short_hex.length();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                if (short_len &lt; 4) {</span>
<span class="nc" id="L396">                    short_hex = &quot;0000&quot;.substring(short_len);</span>
                }
<span class="nc" id="L398">                return &quot;\\u&quot;+short_hex;</span>
            }
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (c &lt; 0xFFFF) {</span>
<span class="nc" id="L401">                String long_hex = Integer.toHexString(c);</span>
<span class="nc" id="L402">                int    long_len = long_hex.length();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (long_len &lt; 4) {</span>
<span class="nc" id="L404">                    long_hex = &quot;00000000&quot;.substring(long_len);</span>
                }
<span class="nc" id="L406">                return &quot;\\U&quot;+long_hex;</span>
            }
        }
<span class="nc" id="L409">        throw new IllegalArgumentException(&quot;the value &quot;+c+&quot; isn't a valid character&quot;);</span>
    }

<span class="fc" id="L412">    private static final boolean invalidTerminatingCharsForInf[] = makeInvalidTerminatingCharsForInfArray();</span>
    private static final boolean [] makeInvalidTerminatingCharsForInfArray() {
<span class="fc" id="L414">        boolean [] values = new boolean [256];</span>

<span class="fc bfc" id="L416" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L417">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L420">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L422" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L423">            values[ii] = true;</span>
        }
<span class="fc" id="L425">        values['$'] = true;</span>
<span class="fc" id="L426">        values['_'] = true;</span>

<span class="fc" id="L428">        return values;</span>
    }
    public final static boolean isValidTerminatingCharForInf(int c) {
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        return !is8bitValue(c) || !invalidTerminatingCharsForInf[c &amp; 0xff];</span>
    }

<span class="fc" id="L434">    private static final boolean isValidExtendedSymbolCharacter[] = makeIsValidExtendedSymbolCharacterArray();</span>
    private static final boolean [] makeIsValidExtendedSymbolCharacterArray() {
<span class="fc" id="L436">        boolean [] values = new boolean [256];</span>

<span class="fc" id="L438">        values['!'] = true;</span>
<span class="fc" id="L439">        values['#'] = true;</span>
<span class="fc" id="L440">        values['%'] = true;</span>
<span class="fc" id="L441">        values['&amp;'] = true;</span>
<span class="fc" id="L442">        values['*'] = true;</span>
<span class="fc" id="L443">        values['+'] = true;</span>
<span class="fc" id="L444">        values['-'] = true;</span>
<span class="fc" id="L445">        values['.'] = true;</span>
<span class="fc" id="L446">        values['/'] = true;</span>
<span class="fc" id="L447">        values[';'] = true;</span>
<span class="fc" id="L448">        values['&lt;'] = true;</span>
<span class="fc" id="L449">        values['='] = true;</span>
<span class="fc" id="L450">        values['&gt;'] = true;</span>
<span class="fc" id="L451">        values['?'] = true;</span>
<span class="fc" id="L452">        values['@'] = true;</span>
<span class="fc" id="L453">        values['^'] = true;</span>
<span class="fc" id="L454">        values['`'] = true;</span>
<span class="fc" id="L455">        values['|'] = true;</span>
<span class="fc" id="L456">        values['~'] = true;</span>

<span class="fc" id="L458">        return values;</span>
    }
    public final static boolean isValidExtendedSymbolCharacter(int c)
    {
<span class="pc bpc" id="L462" title="1 of 4 branches missed.">        return (isValidExtendedSymbolCharacter[c &amp; 0xff] &amp;&amp; is8bitValue(c));</span>
    }

<span class="fc" id="L465">    private static final boolean isValidSymbolCharacter[] = makeIsValidSymbolCharacterArray();</span>
    private static final boolean [] makeIsValidSymbolCharacterArray() {
<span class="fc" id="L467">        boolean [] values = new boolean [256];</span>

<span class="fc bfc" id="L469" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L470">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L472" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L473">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L476">            values[ii] = true;</span>
        }
<span class="fc" id="L478">        values['$'] = true;</span>
<span class="fc" id="L479">        values['_'] = true;</span>

<span class="fc" id="L481">        return values;</span>
    }
    public final static boolean isValidSymbolCharacter(int c)
    {
<span class="pc bpc" id="L485" title="1 of 4 branches missed.">        return (isValidSymbolCharacter[c &amp; 0xff] &amp;&amp; is8bitValue(c));</span>
    }

<span class="fc" id="L488">    private static final boolean isValidStartSymbolCharacter[] = makeIsValidStartSymbolCharacterArray();</span>
    private static final boolean [] makeIsValidStartSymbolCharacterArray() {
<span class="fc" id="L490">        boolean [] values = new boolean [256];</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L493">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L495" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L496">            values[ii] = true;</span>
        }
<span class="fc" id="L498">        values['$'] = true;</span>
<span class="fc" id="L499">        values['_'] = true;</span>

<span class="fc" id="L501">        return values;</span>
    }
    public final static boolean isValidStartSymbolCharacter(int c)
    {
<span class="nc bnc" id="L505" title="All 4 branches missed.">        return (isValidStartSymbolCharacter[c &amp; 0xff] &amp;&amp; is8bitValue(c));</span>
    }

    public static int decodeSid(CharSequence sidToken)
    {
<span class="pc bpc" id="L510" title="2 of 4 branches missed.">        assert sidToken.charAt(0) == '$';</span>

<span class="fc" id="L512">        int length = sidToken.length();</span>
<span class="pc bpc" id="L513" title="2 of 4 branches missed.">        assert length &gt; 1;</span>

<span class="fc" id="L515">        String digits = sidToken.subSequence(1, length).toString();</span>

        try {
<span class="fc" id="L518">            return Integer.parseInt(digits);</span>
<span class="fc" id="L519">        } catch (Exception e) {</span>
<span class="fc" id="L520">            throw new IonException(String.format(&quot;Unable to parse SID %s&quot;, digits), e);</span>
        }
    }

    static public int keyword(CharSequence word, int start_word, int end_word)
    {
<span class="fc" id="L526">        int c = word.charAt(start_word);</span>
<span class="fc" id="L527">        int len = end_word - start_word; // +1 but we build that into the constants below</span>
<span class="fc bfc" id="L528" title="All 11 branches covered.">        switch (c) {</span>
        case '$':
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (len &gt; 1) {</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">                for (int i = start_word + 1; i &lt; end_word; i++) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                    if (! isDigit(word.charAt(i))) return -1;</span>
                }
<span class="fc" id="L534">                return KEYWORD_sid;</span>
            }
<span class="fc" id="L536">            return -1;</span>
        case 'b':
<span class="fc bfc" id="L538" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'o'</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'l'</span>
                ) {
<span class="fc" id="L543">                    return KEYWORD_BOOL;</span>
                }
<span class="fc bfc" id="L545" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'l'</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'b'</span>
                ) {
<span class="fc" id="L549">                    return KEYWORD_BLOB;</span>
                }
            }
<span class="fc" id="L552">            return -1;</span>
        case 'c':
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            if (len == 4) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                if (word.charAt(start_word+1) == 'l'</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'b'</span>
                ) {
<span class="nc" id="L559">                    return KEYWORD_CLOB;</span>
                }
            }
<span class="fc" id="L562">            return -1;</span>
        case 'd':
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (len == 7) {</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                if (word.charAt(start_word+1) == 'e'</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'c'</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'i'</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 'm'</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+5) == 'a'</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+6) == 'l'</span>
                ) {
<span class="nc" id="L572">                    return KEYWORD_DECIMAL;</span>
                }
            }
<span class="fc" id="L575">            return -1;</span>
        case 'f':
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (len == 5) {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'a'</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'l'</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 's'</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 'e'</span>
                ) {
<span class="fc" id="L583">                    return KEYWORD_FALSE;</span>
                }
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                if (word.charAt(start_word+1) == 'l'</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'a'</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 't'</span>
                ) {
<span class="nc" id="L590">                    return KEYWORD_FLOAT;</span>
                }
            }
<span class="fc" id="L593">            return -1;</span>
        case 'i':
<span class="fc bfc" id="L595" title="All 2 branches covered.">            if (len == 3) {</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'n') {</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                    if (word.charAt(start_word+2) == 't') {</span>
<span class="nc" id="L598">                        return KEYWORD_INT;</span>
                    }
                }
            }
<span class="fc" id="L602">            return -1;</span>
        case 'l':
<span class="fc bfc" id="L604" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'i'</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 's'</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 't'</span>
                ) {
<span class="fc" id="L609">                    return KEYWORD_LIST;</span>
                }
            }
<span class="fc" id="L612">            return -1;</span>
        case 'n':
<span class="fc bfc" id="L614" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'u'</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'l'</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'l'</span>
                ) {
<span class="fc" id="L619">                    return KEYWORD_NULL;</span>
                }
            }
<span class="fc bfc" id="L622" title="All 2 branches covered.">            else if (len == 3) {</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'a'</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">                    &amp;&amp; word.charAt(start_word+2) == 'n'</span>
                   ) {
<span class="fc" id="L626">                       return KEYWORD_NAN;</span>
                   }
            }
<span class="fc" id="L629">            return -1;</span>
        case 's':
<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'e'</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'x'</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'p'</span>
                ) {
<span class="fc" id="L636">                    return KEYWORD_SEXP;</span>
                }
            }
<span class="fc bfc" id="L639" title="All 2 branches covered.">            else if (len == 6) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 't'</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'r'</span>
                ) {
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">                    if (word.charAt(start_word+3) == 'i'</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                     &amp;&amp; word.charAt(start_word+4) == 'n'</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                     &amp;&amp; word.charAt(start_word+5) == 'g'</span>
                    ) {
<span class="nc" id="L647">                        return KEYWORD_STRING;</span>
                    }
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                    if (word.charAt(start_word+3) == 'u'</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                     &amp;&amp; word.charAt(start_word+4) == 'c'</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                     &amp;&amp; word.charAt(start_word+5) == 't'</span>
                    ) {
<span class="fc" id="L653">                        return KEYWORD_STRUCT;</span>
                    }
<span class="nc" id="L655">                    return -1;</span>
                }
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'y'</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'm'</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'b'</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 'o'</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+5) == 'l'</span>
                ) {
<span class="fc" id="L663">                    return KEYWORD_SYMBOL;</span>
                }
            }
<span class="fc" id="L666">            return -1;</span>
        case 't':
<span class="fc bfc" id="L668" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'r'</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'u'</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'e'</span>
                ) {
<span class="fc" id="L673">                    return KEYWORD_TRUE;</span>
                }
            }
<span class="fc bfc" id="L676" title="All 2 branches covered.">            else if (len == 9) {</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">                if (word.charAt(start_word+1) == 'i'</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'm'</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'e'</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 's'</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+5) == 't'</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+6) == 'a'</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+7) == 'm'</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+8) == 'p'</span>
                ) {
<span class="nc" id="L686">                    return KEYWORD_TIMESTAMP;</span>
                }
            }
<span class="fc" id="L689">            return -1;</span>
        default:
<span class="fc" id="L691">            return -1;</span>
        }
    }

    /*
    KW_BIT_BLOB       = 0x0001;
    KW_BIT_BOOL       = 0x0002;
    KW_BIT_CLOB       = 0x0004;
    KW_BIT_DECIMAL    = 0x0008;
    KW_BIT_FLOAT      = 0x0010;
    KW_BIT_INT        = 0x0020;
    KW_BIT_LIST       = 0x0030;
    KW_BIT_NULL       = 0x0080;
    KW_BIT_SEXP       = 0x0100;
    KW_BIT_STRING     = 0x0200;
    KW_BIT_STRUCT     = 0x0400;
    KW_BIT_SYMBOL     = 0x0800;
    KW_BIT_TIMESTAMP  = 0x1000;
    datagram is not included (since these are types that can appear as a null type)

    A  1    F  6    N 11    T 16
    B  2    G  7    O 12    U 17
    C  3    I  8    P 13    X 18
    D  4    L  9    R 14    Y 19
    E  5    M 10    S 15

    */
    // this array is [pos][letter_idx] - if this letter is
    // valid in this position then all the type names that
    // contain the letter at that position are on.  Each
    // keyword is assigned a bit value.
    // however due to the double index expense the index
    // is represented by a 1 dim int array and fn's used
    // to access it (since inline-ing final static small methods
    // is easy for the compiler)
<span class="fc" id="L726">    static final int  TN_MAX_NAME_LENGTH = &quot;TIMESTAMP&quot;.length() + 1; // so anything too long will be 0</span>
    static final int  TN_LETTER_MAX_IDX = 19;

    static final int  KW_BIT_BLOB       = 0x0001;
    static final int  KW_BIT_BOOL       = 0x0002;
    static final int  KW_BIT_CLOB       = 0x0004;
    static final int  KW_BIT_DECIMAL    = 0x0008;
    static final int  KW_BIT_FLOAT      = 0x0010;
    static final int  KW_BIT_INT        = 0x0020;
    static final int  KW_BIT_LIST       = 0x0030;
    static final int  KW_BIT_NULL       = 0x0080;
    static final int  KW_BIT_SEXP       = 0x0100;
    static final int  KW_BIT_STRING     = 0x0200;
    static final int  KW_BIT_STRUCT     = 0x0400;
    static final int  KW_BIT_SYMBOL     = 0x0800;
    static final int  KW_BIT_TIMESTAMP  = 0x1000;
    static final int  KW_ALL_BITS       = 0x1fff;

<span class="fc" id="L744">    static final int[] typeNameBits = new int[] {</span>
        KW_BIT_BLOB,      KW_BIT_BOOL,    KW_BIT_CLOB,
        KW_BIT_DECIMAL,   KW_BIT_FLOAT,   KW_BIT_INT,
        KW_BIT_LIST,      KW_BIT_NULL,    KW_BIT_SEXP,
        KW_BIT_STRING,    KW_BIT_STRUCT,  KW_BIT_SYMBOL,
        KW_BIT_TIMESTAMP
    };

<span class="fc" id="L752">    static final String[] typeNameNames = new String[] {</span>
        &quot;blob&quot;,           &quot;bool&quot;,         &quot;clob&quot;,
        &quot;decimal&quot;,        &quot;float&quot;,        &quot;int&quot;,
        &quot;list&quot;,           &quot;null&quot;,         &quot;sexp&quot;,
        &quot;string&quot;,         &quot;struct&quot;,       &quot;symbol&quot;,
        &quot;timestamp&quot;
    };
<span class="fc" id="L759">    static final int[] typeNameKeyWordIds = new int[] {</span>
        KEYWORD_BLOB,     KEYWORD_BOOL,   KEYWORD_CLOB,
        KEYWORD_DECIMAL,  KEYWORD_FLOAT,  KEYWORD_INT,
        KEYWORD_LIST,     KEYWORD_NULL,   KEYWORD_SEXP,
        KEYWORD_STRING,   KEYWORD_STRUCT, KEYWORD_SYMBOL,
        KEYWORD_TIMESTAMP
    };

<span class="fc" id="L767">    static final int[] TypeNameBitIndex = makeTypeNameBitIndex();</span>
    static final int[] makeTypeNameBitIndex() {
<span class="fc" id="L769">        int[] bits = new int[TN_MAX_NAME_LENGTH*TN_LETTER_MAX_IDX];</span>
        int   typename_bit;
<span class="fc bfc" id="L771" title="All 2 branches covered.">        for (int tt=0; tt&lt;typeNameNames.length; tt++) {</span>
<span class="fc" id="L772">            String typename = typeNameNames[tt];</span>
<span class="fc" id="L773">            typename_bit = typeNameBits[tt];</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">            for (int ii=0; ii&lt;typename.length(); ii++) {</span>
<span class="fc" id="L775">                int c = typename.charAt(ii);</span>
<span class="fc" id="L776">                int l = typeNameLetterIdx(c);</span>
<span class="pc bpc" id="L777" title="2 of 4 branches missed.">                assert(l &gt; 0);</span>
<span class="fc" id="L778">                typename_set_bit(bits, ii, l, typename_bit);</span>
            }
        }
<span class="fc" id="L781">        return bits;</span>
    }
    private final static void typename_set_bit(int[] bits, int ii, int l, int typename_bit)
    {
        // bits[ii][l]
<span class="fc" id="L786">        int idx = (ii * TN_LETTER_MAX_IDX) + l - 1;</span>
<span class="fc" id="L787">        bits[idx] |= typename_bit;</span>
<span class="fc" id="L788">    }</span>
    public final static int typeNameLetterIdx(int c) {
<span class="fc bfc" id="L790" title="All 20 branches covered.">        switch(c) {</span>
<span class="fc" id="L791">        case 'a': return  1;</span>
<span class="fc" id="L792">        case 'b': return  2;</span>
<span class="fc" id="L793">        case 'c': return  3;</span>
<span class="fc" id="L794">        case 'd': return  4;</span>
<span class="fc" id="L795">        case 'e': return  5;</span>
<span class="fc" id="L796">        case 'f': return  6;</span>
<span class="fc" id="L797">        case 'g': return  7;</span>
<span class="fc" id="L798">        case 'i': return  8;</span>
<span class="fc" id="L799">        case 'l': return  9;</span>
<span class="fc" id="L800">        case 'm': return 10;</span>
<span class="fc" id="L801">        case 'n': return 11;</span>
<span class="fc" id="L802">        case 'o': return 12;</span>
<span class="fc" id="L803">        case 'p': return 13;</span>
<span class="fc" id="L804">        case 'r': return 14;</span>
<span class="fc" id="L805">        case 's': return 15;</span>
<span class="fc" id="L806">        case 't': return 16;</span>
<span class="fc" id="L807">        case 'u': return 17;</span>
<span class="fc" id="L808">        case 'x': return 18;</span>
<span class="fc" id="L809">        case 'y': return 19;</span>
<span class="fc" id="L810">        default:  return -1;</span>
        }
    }
    public final static int typeNamePossibilityMask(int pos, int letter_idx) {
<span class="fc" id="L814">        int idx = (pos * TN_LETTER_MAX_IDX) + letter_idx - 1;</span>
<span class="fc" id="L815">        int mask = TypeNameBitIndex[idx];</span>
<span class="fc" id="L816">        return mask;</span>
    }
    // this can be faster but it's pretty unusual to be called.
    public final static int typeNameKeyWordFromMask(int possible_names, int length) {
<span class="fc" id="L820">        int kw = KEYWORD_unrecognized;</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (possible_names != IonTokenConstsX.KW_ALL_BITS) {</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            for (int ii=0; ii&lt;typeNameBits.length; ii++) {</span>
<span class="fc" id="L823">                int tb = typeNameBits[ii];</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">                if (tb == possible_names) {</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">                    if (typeNameNames[ii].length() == length) {</span>
<span class="fc" id="L826">                        kw = typeNameKeyWordIds[ii];</span>
                    }
                    break;
                }
            }
        }
<span class="fc" id="L832">        return kw;</span>
    }
    public static final String getNullImage(IonType type)
    {
<span class="nc" id="L836">        String nullimage = null;</span>

<span class="nc bnc" id="L838" title="All 14 branches missed.">        switch (type) {</span>
<span class="nc" id="L839">        case NULL:      nullimage = &quot;null&quot;;           break;</span>
<span class="nc" id="L840">        case BOOL:      nullimage = &quot;null.bool&quot;;      break;</span>
<span class="nc" id="L841">        case INT:       nullimage = &quot;null.int&quot;;       break;</span>
<span class="nc" id="L842">        case FLOAT:     nullimage = &quot;null.float&quot;;     break;</span>
<span class="nc" id="L843">        case DECIMAL:   nullimage = &quot;null.decimal&quot;;   break;</span>
<span class="nc" id="L844">        case TIMESTAMP: nullimage = &quot;null.timestamp&quot;; break;</span>
<span class="nc" id="L845">        case SYMBOL:    nullimage = &quot;null.symbol&quot;;    break;</span>
<span class="nc" id="L846">        case STRING:    nullimage = &quot;null.string&quot;;    break;</span>
<span class="nc" id="L847">        case BLOB:      nullimage = &quot;null.blob&quot;;      break;</span>
<span class="nc" id="L848">        case CLOB:      nullimage = &quot;null.clob&quot;;      break;</span>
<span class="nc" id="L849">        case SEXP:      nullimage = &quot;null.sexp&quot;;      break;</span>
<span class="nc" id="L850">        case LIST:      nullimage = &quot;null.list&quot;;      break;</span>
<span class="nc" id="L851">        case STRUCT:    nullimage = &quot;null.struct&quot;;    break;</span>

<span class="nc" id="L853">        default: throw new IllegalStateException(&quot;unexpected type &quot; + type);</span>
        }

<span class="nc" id="L856">        return nullimage;</span>
    }
    public static final IonType getNullType(CharSequence s)
    {
<span class="nc" id="L860">        IonType type = null;</span>
<span class="nc" id="L861">        int     c, ii = 0;</span>
<span class="nc" id="L862">        boolean stop = false;</span>
<span class="nc bnc" id="L863" title="All 4 branches missed.">        while (!stop &amp;&amp; ii&lt;s.length()) {</span>
<span class="nc" id="L864">            c = s.charAt(ii++);</span>
<span class="nc bnc" id="L865" title="All 3 branches missed.">            switch (c) {</span>
            case ' ': case '\t': case '\r': case '\n':
<span class="nc" id="L867">                break;</span>
            case 'n':
<span class="nc" id="L869">                stop = true;</span>
<span class="nc" id="L870">                break;</span>
            default:
<span class="nc" id="L872">                invalid_null_image(s);</span>
            }
        }
<span class="nc bnc" id="L875" title="All 4 branches missed.">        if (ii&gt;=s.length() || s.charAt(ii++) != 'u') invalid_null_image(s);</span>
<span class="nc bnc" id="L876" title="All 4 branches missed.">        if (ii&gt;=s.length() || s.charAt(ii++) != 'l') invalid_null_image(s);</span>
<span class="nc bnc" id="L877" title="All 4 branches missed.">        if (ii&gt;=s.length() || s.charAt(ii++) != 'l') invalid_null_image(s);</span>
<span class="nc" id="L878">        boolean dot = false;</span>
<span class="nc bnc" id="L879" title="All 4 branches missed.">        while (!dot &amp;&amp; ii&lt;s.length()) {</span>
<span class="nc" id="L880">            c = s.charAt(ii++);</span>
<span class="nc bnc" id="L881" title="All 3 branches missed.">            switch (c) {</span>
            case ' ': case '\t': case '\r': case '\n':
<span class="nc" id="L883">                break;</span>
            case '.':
<span class="nc" id="L885">                dot = true;</span>
<span class="nc" id="L886">                break;</span>
            default:
<span class="nc" id="L888">                invalid_null_image(s);</span>
            }
        }
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (dot) {</span>
<span class="nc" id="L892">            int kw = IonTokenConstsX.keyword(s, ii, s.length());</span>
<span class="nc bnc" id="L893" title="All 14 branches missed.">            switch (kw) {</span>
                case IonTokenConstsX.KEYWORD_NULL:
<span class="nc" id="L895">                    type = IonType.NULL;</span>
<span class="nc" id="L896">                    break;</span>
                case IonTokenConstsX.KEYWORD_BOOL:
<span class="nc" id="L898">                    type = IonType.BOOL;</span>
<span class="nc" id="L899">                    break;</span>
                case IonTokenConstsX.KEYWORD_INT:
<span class="nc" id="L901">                    type = IonType.INT;</span>
<span class="nc" id="L902">                    break;</span>
                case IonTokenConstsX.KEYWORD_FLOAT:
<span class="nc" id="L904">                    type = IonType.FLOAT;</span>
<span class="nc" id="L905">                    break;</span>
                case IonTokenConstsX.KEYWORD_DECIMAL:
<span class="nc" id="L907">                    type = IonType.DECIMAL;</span>
<span class="nc" id="L908">                    break;</span>
                case IonTokenConstsX.KEYWORD_TIMESTAMP:
<span class="nc" id="L910">                    type = IonType.TIMESTAMP;</span>
<span class="nc" id="L911">                    break;</span>
                case IonTokenConstsX.KEYWORD_SYMBOL:
<span class="nc" id="L913">                    type = IonType.SYMBOL;</span>
<span class="nc" id="L914">                    break;</span>
                case IonTokenConstsX.KEYWORD_STRING:
<span class="nc" id="L916">                    type = IonType.STRING;</span>
<span class="nc" id="L917">                    break;</span>
                case IonTokenConstsX.KEYWORD_CLOB:
<span class="nc" id="L919">                    type = IonType.CLOB;</span>
<span class="nc" id="L920">                    break;</span>
                case IonTokenConstsX.KEYWORD_BLOB:
<span class="nc" id="L922">                    type = IonType.BLOB;</span>
<span class="nc" id="L923">                    break;</span>
                case IonTokenConstsX.KEYWORD_STRUCT:
<span class="nc" id="L925">                    type = IonType.STRUCT;</span>
<span class="nc" id="L926">                    break;</span>
                case IonTokenConstsX.KEYWORD_LIST:
<span class="nc" id="L928">                    type = IonType.LIST;</span>
<span class="nc" id="L929">                    break;</span>
                case IonTokenConstsX.KEYWORD_SEXP:
<span class="nc" id="L931">                    type = IonType.SEXP;</span>
<span class="nc" id="L932">                    break;</span>
                default:
<span class="nc" id="L934">                    invalid_null_image(s);</span>
            }
        }

<span class="nc bnc" id="L938" title="All 2 branches missed.">        while (ii&lt;s.length()) {</span>
<span class="nc" id="L939">            c = s.charAt(ii++);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">            switch (c) {</span>
            case ' ': case '\t': case '\r': case '\n':
<span class="nc" id="L942">                break;</span>
            default:
<span class="nc" id="L944">                invalid_null_image(s);</span>
            }
        }

<span class="nc" id="L948">        return type;</span>
    }
    private static void invalid_null_image(CharSequence s) {
<span class="nc" id="L951">        throw new CantConvertException(&quot;invalid image &quot;+s.toString());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>