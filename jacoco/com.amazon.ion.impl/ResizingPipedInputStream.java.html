<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResizingPipedInputStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">ResizingPipedInputStream.java</span></div><h1>ResizingPipedInputStream.java</h1><pre class="source lang-java linenums">package com.amazon.ion.impl;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;

/**
 * Manages a resizing buffer for production and consumption of data within a &lt;strong&gt;single thread&lt;/strong&gt;.
 * Buffered bytes may be consumed through the InputStream interface. This provides a few benefits over using
 * a PipedOutputStream/PipedInputStream pair in a single thread:
 * &lt;ol&gt;
 *     &lt;li&gt;There is no risk of deadlock. Piped streams, which are intended for producing data in one
 *     thread and consuming it in another, will block on read when no data is available and block on write
 *     when the buffer is full. In a single-threaded context, avoiding deadlock on read requires checking
 *     that bytes are available before every read. Avoiding deadlock on write would require checking that
 *     the buffer is not full before every write, but there is no built-in, publicly-accessible way of doing
 *     this with a PipedInputStream/PipedOutputStream.&lt;/li&gt;
 *     &lt;li&gt;The buffer can grow. Piped streams use a fixed-size buffer that causes blocking when full. If
 *     used in a single-thread, this serves as a hard limit on the amount of data that can be written without
 *     a matching read. This can require arbitrary limits on data size to be imposed by the application. The
 *     ResizingPipedInputStream imposes no such limitation, but optionally allows for a maximum buffer
 *     size to be configured to protect against unbounded growth.&lt;/li&gt;
 * &lt;/ol&gt;
 */
public class ResizingPipedInputStream extends InputStream {

    /**
     * Handler of notifications provided by the ResizingPipedInputStream.
     */
    interface NotificationConsumer {

        /**
         * Bytes have been shifted to the start of the buffer in order to make room for additional bytes
         * to be buffered.
         * @param leftShiftAmount the amount of the left shift (also: the pre-shift read index of the first shifted
         *                        byte).
         */
        void bytesConsolidatedToStartOfBuffer(int leftShiftAmount);
    }

    /**
     * A NotificationConsumer that does nothing.
     */
<span class="fc" id="L47">    private static final NotificationConsumer NO_OP_NOTIFICATION_CONSUMER = new NotificationConsumer() {</span>
        @Override
        public void bytesConsolidatedToStartOfBuffer(int leftShiftAmount) {
            // Do nothing.
<span class="fc" id="L51">        }</span>
    };

    /**
     * Mask to isolate a single byte.
     */
    private static final int SINGLE_BYTE_MASK = 0xFF;

    /**
     * The initial size of the buffer and the number of bytes by which the size of the buffer will increase
     * each time it grows, unless it must grow by a smaller amount to fit within 'maximumBufferSize'.
     */
    private final int initialBufferSize;

    /**
     * The maximum size of the buffer. If the user attempts to buffer more bytes than this, an exception will be raised.
     */
    private final int maximumBufferSize;

    /**
     * Whether to use a boundary to limit the number of available bytes. This can be used to buffer
     * arbitrarily-sized chunks of bytes without making them available for consumption. When true,
     * the boundary must be manually extended (see {@link #extendBoundary(int)} to make these bytes
     * available. When false, all buffered bytes will be available to read.
     */
    private final boolean useBoundary;

    /**
     * The NotificationConsumer currently registered.
     */
<span class="fc" id="L81">    private NotificationConsumer notificationConsumer = NO_OP_NOTIFICATION_CONSUMER;</span>

    /**
     * The raw buffer.
     */
    private byte[] buffer;

    /**
     * View to the raw buffer.
     */
    private ByteBuffer byteBuffer;

    /**
     * @see #capacity()
     */
    private int capacity;

    /**
     * The index of the next byte in the buffer that is available to be read. Always less than or equal to `writeIndex`.
     */
<span class="fc" id="L101">    private int readIndex = 0;</span>

    /**
     * The index at which the next byte received will be written. Always greater than or equal to `readIndex`.
     */
<span class="fc" id="L106">    private int writeIndex = 0;</span>

    /**
     * @see #available()
     */
<span class="fc" id="L111">    private int available = 0;</span>

    /**
     * @see #size()
     */
<span class="fc" id="L116">    private int size = 0;</span>

    /**
     * @see #getBoundary()
     */
<span class="fc" id="L121">    private int boundary = 0;</span>

    /**
     * Constructor.
     * @param initialBufferSize the initial size of the buffer. When full, the buffer will grow by this
     *                          many bytes. The buffer always stores bytes contiguously, so growth requires
     *                          allocation of a new buffer capable of holding the new capacity and copying of the
     *                          existing bytes into the new buffer. As such, a size should be chosen carefully
     *                          such that growth is expected to occur rarely, if ever.
     */
    public ResizingPipedInputStream(final int initialBufferSize) {
<span class="fc" id="L132">        this(initialBufferSize, Integer.MAX_VALUE, false);</span>
<span class="fc" id="L133">    }</span>

    /**
     * Constructor.
     * @param initialBufferSize the initial size of the buffer. When full, the buffer will grow by this
     *                          many bytes. The buffer always stores bytes contiguously, so growth requires
     *                          allocation of a new buffer capable of holding the new capacity and copying of the
     *                          existing bytes into the new buffer. As such, a size should be chosen carefully
     *                          such that growth is expected to occur rarely, if ever.
     * @param maximumBufferSize the maximum size of the buffer. If a call to `receive` attempts to transfer an amount
     *                          of bytes that would cause the buffer to exceed this size, a
     *                          {@link BufferOverflowException} will be thrown. Must be greater than or equal to the
     *                          initial buffer size.
     * @param useBoundary whether to use a boundary to limit the number of available bytes. This can be used to buffer
     *                    arbitrarily-sized chunks of bytes without making them available for consumption. When true,
     *                    the boundary must be manually extended (see {@link #extendBoundary(int)} to make these bytes
     *                    available. When false, all buffered bytes will be available to read.
     */
<span class="fc" id="L151">    ResizingPipedInputStream(final int initialBufferSize, final int maximumBufferSize, final boolean useBoundary) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (initialBufferSize &lt; 1) {</span>
<span class="fc" id="L153">            throw new IllegalArgumentException(&quot;Initial buffer size must be at least 1.&quot;);</span>
        }
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (maximumBufferSize &lt; initialBufferSize) {</span>
<span class="fc" id="L156">            throw new IllegalArgumentException(&quot;Maximum buffer size cannot be less than the initial buffer size.&quot;);</span>
        }
<span class="fc" id="L158">        this.initialBufferSize = initialBufferSize;</span>
<span class="fc" id="L159">        this.maximumBufferSize = maximumBufferSize;</span>
<span class="fc" id="L160">        this.capacity = initialBufferSize;</span>
<span class="fc" id="L161">        buffer = new byte[initialBufferSize];</span>
<span class="fc" id="L162">        byteBuffer = ByteBuffer.wrap(buffer, 0, capacity);</span>
<span class="fc" id="L163">        this.useBoundary = useBoundary;</span>
<span class="fc" id="L164">    }</span>

    /**
     * Moves all buffered (but not yet read) bytes from 'buffer' to the destination buffer. In total, {@link #size()}
     * bytes will be moved.
     * @param destinationBuffer the destination buffer, which may be 'buffer' itself or a new buffer.
     */
    private void moveBytesToStartOfBuffer(byte[] destinationBuffer) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (size &gt; 0) {</span>
<span class="fc" id="L173">            System.arraycopy(buffer, readIndex, destinationBuffer, 0, size);</span>
        }
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (readIndex &gt; 0) {</span>
<span class="fc" id="L176">            notificationConsumer.bytesConsolidatedToStartOfBuffer(readIndex);</span>
        }
<span class="fc" id="L178">        readIndex = 0;</span>
<span class="fc" id="L179">        boundary = available;</span>
<span class="fc" id="L180">        writeIndex = size;</span>
<span class="fc" id="L181">    }</span>

    /**
     * @return the number of bytes that can be written at the end of the buffer.
     */
    private int freeSpaceAtEndOfBuffer() {
<span class="fc" id="L187">        return capacity - writeIndex;</span>
    }

    /**
     * Ensures that there is at least 'minimumNumberOfBytesRequired' bytes of free space in the buffer, growing the
     * buffer if necessary. May consolidate buffered bytes, performing an in-order copy and resetting indices
     * such that the `readIndex` points to the same byte and the `writeIndex` is positioned after the last
     * byte that is available to read.
     * @param minimumNumberOfBytesRequired the minimum amount of free space that needs to be available for writing.
     */
    private void ensureSpaceInBuffer(int minimumNumberOfBytesRequired) {
<span class="fc bfc" id="L198" title="All 4 branches covered.">        if (size &lt; 1 || freeSpaceAtEndOfBuffer() &lt; minimumNumberOfBytesRequired) {</span>
<span class="fc" id="L199">            int shortfall = minimumNumberOfBytesRequired - freeSpaceAtEndOfBuffer() - readIndex;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (shortfall &lt;= 0) {</span>
                // Free up space by moving any unread bytes to the start of the buffer and resetting the indices.
<span class="fc" id="L202">                moveBytesToStartOfBuffer(buffer);</span>
            } else {
                // There is not enough space in the buffer even though all available bytes have already been
                // moved to the start of the buffer. Growth is required.
<span class="fc" id="L206">                int amountToGrow = Math.max(initialBufferSize, shortfall);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if (capacity + amountToGrow &gt; maximumBufferSize) {</span>
<span class="fc" id="L208">                    amountToGrow = shortfall;</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                    if (capacity + amountToGrow &gt; maximumBufferSize) {</span>
<span class="fc" id="L210">                        throw new BufferOverflowException();</span>
                    }
                }
<span class="fc" id="L213">                byte[] newBuffer = new byte[buffer.length + amountToGrow];</span>
<span class="fc" id="L214">                moveBytesToStartOfBuffer(newBuffer);</span>
<span class="fc" id="L215">                capacity += amountToGrow;</span>
<span class="fc" id="L216">                buffer = newBuffer;</span>
<span class="fc" id="L217">                byteBuffer = ByteBuffer.wrap(buffer, readIndex, capacity);</span>
            }
        }
<span class="fc" id="L220">    }</span>

    /**
     * Buffers a single additional byte, growing the buffer if it is already full.
     * @param b the byte to buffer.
     */
    public void receive(final int b) {
<span class="fc" id="L227">        ensureSpaceInBuffer(1);</span>
<span class="fc" id="L228">        buffer[writeIndex] = (byte) b;</span>
<span class="fc" id="L229">        writeIndex++;</span>
<span class="fc" id="L230">        size++;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (!useBoundary) {</span>
<span class="fc" id="L232">            extendBoundary(1);</span>
        }
<span class="fc" id="L234">    }</span>

    /**
     * Buffers `len` additional bytes, growing the buffer if it is already full or if it would become full
     * by writing `len` bytes.
     * @param b the bytes to buffer.
     * @param off the offset into `b` that points to the first byte to buffer.
     * @param len the number of bytes to buffer.
     */
    public void receive(final byte[] b, final int off, final int len) {
<span class="fc" id="L244">        ensureSpaceInBuffer(len);</span>
<span class="fc" id="L245">        System.arraycopy(b, off, buffer, writeIndex, len);</span>
<span class="fc" id="L246">        writeIndex += len;</span>
<span class="fc" id="L247">        size += len;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (!useBoundary) {</span>
<span class="fc" id="L249">            extendBoundary(len);</span>
        }
<span class="fc" id="L251">    }</span>

    /**
     * Buffers `b.length` additional bytes.
     * @see #receive(byte[], int, int)
     * @param b the bytes to buffer.
     */
    public void receive(final byte[] b) {
<span class="fc" id="L259">        receive(b, 0, b.length);</span>
<span class="fc" id="L260">    }</span>

    /**
     * Buffers up to `len` additional bytes, growing the buffer if it is already full or if it would become full
     * by writing `len` bytes. This method will block if and only if the given `InputStream`'s
     * {@link InputStream#read(byte[], int, int)} blocks when trying to read `len` bytes. If this is not desired,
     * the caller should ensure that the given `InputStream` has at least `len` bytes available before calling
     * this method or provide an InputStream implementation that does not block.
     * @param input the source of the bytes.
     * @param len the number of bytes to attempt to write.
     * @return the number of bytes actually written, which will only be less than `len` if
     * {@link InputStream#read(byte[], int, int)} returns less than `len`.
     * @throws IOException if thrown by the given `InputStream` during read, except for {@link EOFException}. If an
     *   EOFException is thrown by the `InputStream`, it will be caught and this method will return the number of bytes
     *   that were received before the exception was thrown.
     */
    public int receive(final InputStream input, final int len) throws IOException  {
<span class="fc" id="L277">        ensureSpaceInBuffer(len);</span>
        int numberOfBytesRead;
        try {
<span class="fc" id="L280">            numberOfBytesRead = input.read(buffer, writeIndex, len);</span>
<span class="fc" id="L281">        } catch (EOFException e) {</span>
            // Some InputStream implementations (such as GZIPInputStream) will throw EOFException instead of
            // returning -1.
<span class="fc" id="L284">            numberOfBytesRead = -1;</span>
<span class="fc" id="L285">        }</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (numberOfBytesRead &gt; 0) {</span>
<span class="fc" id="L287">            writeIndex += numberOfBytesRead;</span>
<span class="fc" id="L288">            size += numberOfBytesRead;</span>
        } else {
<span class="fc" id="L290">            numberOfBytesRead = 0;</span>
        }
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (!useBoundary) {</span>
<span class="fc" id="L293">            extendBoundary(numberOfBytesRead);</span>
        }
<span class="fc" id="L295">        return numberOfBytesRead;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * NOTE: This method adheres to the documented behavior of {@link InputStream#read(byte[], int, int)}
     * &lt;strong&gt;except&lt;/strong&gt; that it never blocks. If a read is attempted before the first write,
     * this method will return -1.
     */
    @Override
    public int read(final byte[] b, final int off, final int len) {
<span class="fc bfc" id="L307" title="All 4 branches covered.">        if (b.length == 0 || len == 0) {</span>
<span class="fc" id="L308">            return 0;</span>
        }
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (available &lt; 1) {</span>
<span class="fc" id="L311">            return -1;</span>
        }
<span class="fc" id="L313">        int bytesToRead = Math.min(available, len);</span>
<span class="fc" id="L314">        System.arraycopy(buffer, readIndex, b, off, bytesToRead);</span>
<span class="fc" id="L315">        readIndex += bytesToRead;</span>
<span class="fc" id="L316">        available -= bytesToRead;</span>
<span class="fc" id="L317">        size -= bytesToRead;</span>
<span class="fc" id="L318">        return bytesToRead;</span>
    }

    /**
     * Copies all of the available bytes in the buffer without changing the number of bytes available to subsequent
     * reads.
     * @param outputStream stream to which the bytes will be copied.
     * @throws IOException if thrown by {@link OutputStream#write(byte[], int, int)}.
     */
    public void copyTo(final OutputStream outputStream) throws IOException {
<span class="fc" id="L328">        outputStream.write(buffer, readIndex, available);</span>
<span class="fc" id="L329">    }</span>

    /**
     * Seeks the read index to the given position.
     * @param index the index to which to seek. Must not be negative.
     */
    void seekTo(int index) {
<span class="fc" id="L336">        int amount = index - readIndex;</span>
<span class="fc" id="L337">        available -= amount;</span>
<span class="fc" id="L338">        size -= amount;</span>
<span class="fc" id="L339">        readIndex = index;</span>
<span class="fc" id="L340">    }</span>

    /**
     * @return the current read index.
     */
    int getReadIndex() {
<span class="fc" id="L346">        return readIndex;</span>
    }

    /**
     * @return the current write index.
     */
    int getWriteIndex() {
<span class="fc" id="L353">        return writeIndex;</span>
    }

    /**
     * Rewinds the buffer to the given read index and sets 'available' to the given value. Subsequent
     * behavior is undefined unless the values resulted from calling {@link #getReadIndex()} and
     * {@link #available()} in immediate sequence, without any calls to 'receive' since.
     * @param previousReadIndex the read index value to be set.
     * @param previousAvailable the available value to be set.
     */
    void rewind(final int previousReadIndex, final int previousAvailable) {
<span class="fc" id="L364">        readIndex = previousReadIndex;</span>
<span class="fc" id="L365">        available = previousAvailable;</span>
<span class="fc" id="L366">        boundary = previousReadIndex + previousAvailable;</span>
<span class="fc" id="L367">        size = writeIndex - readIndex;</span>
<span class="fc" id="L368">    }</span>

    /**
     * Truncates the buffer to the given write index and sets both 'available' and 'size' to the to the given value.
     * Subsequent behavior is undefined unless the values resulted from calling {@link #getWriteIndex()} and
     * {@link #available()} in immediate sequence, without any calls to 'read' or 'skip' since. It is the caller's
     * responsibility to ensure that calling this method will not result in loss of important data beyond the boundary.
     * @param previousWriteIndex the write index value to be set.
     * @param previousAvailable the available value to be set.
     */
    void truncate(final int previousWriteIndex, final int previousAvailable) {
<span class="fc" id="L379">        writeIndex = previousWriteIndex;</span>
<span class="fc" id="L380">        available = previousAvailable;</span>
<span class="fc" id="L381">        boundary = writeIndex;</span>
<span class="fc" id="L382">        size = previousAvailable;</span>
<span class="fc" id="L383">    }</span>

    /**
     * Skips up to `n` buffered bytes. Less than `n` bytes will be skipped if less than `n` bytes are
     * available in the buffer.
     * @param n the number of bytes to skip.
     * @return the number of bytes actually skipped.
     */
    @Override
    public long skip(final long n) {
<span class="fc bfc" id="L393" title="All 4 branches covered.">        if (n &lt; 1 || available &lt; 1) {</span>
<span class="fc" id="L394">            return 0;</span>
        }
<span class="fc" id="L396">        int bytesSkipped = (int) Math.min(available, n);</span>
<span class="fc" id="L397">        readIndex += bytesSkipped;</span>
<span class="fc" id="L398">        available -= bytesSkipped;</span>
<span class="fc" id="L399">        size -= bytesSkipped;</span>
<span class="fc" id="L400">        return bytesSkipped;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * NOTE: This method adheres to the documented behavior of {@link InputStream#available()}
     * &lt;strong&gt;except&lt;/strong&gt; that it always returns the exact number of bytes that are available in the
     * buffer.
     * @return the exact number of bytes available in the buffer.
     */
    @Override
    public int available() {
<span class="fc" id="L413">        return available;</span>
    }

    /**
     * @return the number of bytes actually buffered, which will be greater than or equal to 'available' if a boundary
     *   has been set, or equal to `available` if no boundary has been set.
     */
    int size() {
<span class="fc" id="L421">        return size;</span>
    }

    /**
     * @return the number of bytes buffered beyond the boundary. This is equivalent to subtracting {@link #available()}
     * from {@link #size()}.
     */
    int availableBeyondBoundary() {
<span class="fc" id="L429">        return size - available;</span>
    }

    /**
     * @return the index of the boundary, which is used to mark the last buffered byte that is available for reading.
     *   The boundary must always fall within [readIndex, writeIndex].
     */
    int getBoundary() {
<span class="fc" id="L437">        return boundary;</span>
    }

    /**
     * Extends the boundary by the given number of bytes. It is the caller's responsibility to ensure that the
     * resulting boundary includes only bytes that have been buffered (i.e. that it does not exceed `writeIndex`).
     * @param numberOfBytes the number of bytes by which the boundary should be extended.
     */
    void extendBoundary(int numberOfBytes) {
<span class="fc" id="L446">        boundary += numberOfBytes;</span>
<span class="fc" id="L447">        available += numberOfBytes;</span>
<span class="fc" id="L448">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * NOTE: This method adheres to the documented behavior of {@link InputStream#read(byte[], int, int)}
     * &lt;strong&gt;except&lt;/strong&gt; that it never blocks. If a read is attempted before the first write,
     * this method will return -1.
     */
    @Override
    public int read() {
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (available &lt; 1) {</span>
<span class="fc" id="L460">            return -1;</span>
        }
<span class="fc" id="L462">        int b = buffer[readIndex];</span>
<span class="fc" id="L463">        readIndex++;</span>
<span class="fc" id="L464">        available--;</span>
<span class="fc" id="L465">        size--;</span>
<span class="fc" id="L466">        return b &amp; SINGLE_BYTE_MASK;</span>
    }

    /**
     * Peeks the byte at the given index without modifying any internal indexes. It is the caller's responsibility to
     * ensure that the given index points to an available byte.
     * @param index the index of the byte to peek.
     * @return the byte value.
     */
    int peek(int index) {
<span class="fc" id="L476">        return buffer[index] &amp; SINGLE_BYTE_MASK;</span>
    }

    /**
     * @return the capacity of the buffer, which is always less than or equal to 'maximumBufferSize'.
     */
    public int capacity() {
<span class="fc" id="L483">        return capacity;</span>
    }

    /**
     * @return the initial capacity of the buffer.
     */
    int getInitialBufferSize() {
<span class="fc" id="L490">        return initialBufferSize;</span>
    }

    /**
     * Clears the buffer.
     */
    void clear() {
<span class="fc" id="L497">        readIndex = 0;</span>
<span class="fc" id="L498">        writeIndex = 0;</span>
<span class="fc" id="L499">        available = 0;</span>
<span class="fc" id="L500">        boundary = 0;</span>
<span class="fc" id="L501">        size = 0;</span>
<span class="fc" id="L502">    }</span>

    /**
     * Returns a ByteBuffer view of the underlying buffer.
     * @param position the start position of the ByteBuffer.
     * @param limit the limit of the ByteBuffer.
     * @return a ByteBuffer.
     */
    ByteBuffer getByteBuffer(int position, int limit) {
        // Setting the limit to the capacity first is required because setting the position will fail if the new
        // position is outside the limit.
<span class="fc" id="L513">        byteBuffer.limit(capacity);</span>
<span class="fc" id="L514">        byteBuffer.position(position);</span>
<span class="fc" id="L515">        byteBuffer.limit(limit);</span>
<span class="fc" id="L516">        return byteBuffer;</span>
    }

    /**
     * Copies bytes from the underlying buffer. It is the caller's responsibility to ensure the requested bytes
     * are available.
     * @param position the start position from which to read.
     * @param destination the buffer to copy into.
     * @param destinationOffset the offset of the buffer to copy into.
     * @param length the number of bytes to copy.
     */
    void copyBytes(int position, byte[] destination, int destinationOffset, int length) {
<span class="fc" id="L528">        System.arraycopy(buffer, position, destination, destinationOffset, length);</span>
<span class="fc" id="L529">    }</span>

    /**
     * Moves all bytes starting at 'fromPosition' to 'toPosition', overwriting the bytes in-between. It is the caller's
     * responsibility to ensure that the overwritten bytes are not needed.
     * @param fromPosition the position to move bytes from. Must be less than or equal to 'writeIndex' and 'boundary'.
     * @param toPosition the position to move bytes to. Must be greater than or equal to 'readIndex'.
     */
    void consolidate(int fromPosition, int toPosition) {
<span class="fc bfc" id="L538" title="All 6 branches covered.">        if (fromPosition &gt; writeIndex || fromPosition &gt; boundary || toPosition &lt; readIndex) {</span>
<span class="fc" id="L539">            throw new IllegalArgumentException(&quot;Tried to consolidate using an index that violates the constraints.&quot;);</span>
        }
<span class="fc" id="L541">        int indexShift = fromPosition - toPosition;</span>
<span class="fc" id="L542">        System.arraycopy(buffer, fromPosition, buffer, toPosition, writeIndex - fromPosition);</span>
<span class="fc" id="L543">        size -= indexShift;</span>
<span class="fc" id="L544">        available -= indexShift;</span>
<span class="fc" id="L545">        writeIndex -= indexShift;</span>
<span class="fc" id="L546">        boundary -= indexShift;</span>
        // readIndex does not need to change, because none of the consolidated bytes have been read yet.
<span class="fc" id="L548">    }</span>

    /**
     * Registers the given NotificationConsumer.
     * @param consumer the NotificationConsumer to register.
     */
    void registerNotificationConsumer(NotificationConsumer consumer) {
<span class="fc" id="L555">        notificationConsumer = consumer;</span>
<span class="fc" id="L556">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>